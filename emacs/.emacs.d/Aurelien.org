#+TITLE: Aur√©lien Bottazini's Emacs configuration
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :results silent

*IN_PROGRESS*

I am in the process of refactoring this emacs dotfile.
I want to explain my emacs config strategy to

- Make it easier for others to copy things from it.
- To teach myself better emacs strategies.

* Setup

  It is important to load
  those first as it can impact the loading of other packages
#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)
#+end_src

  I keep my machine specific settings here.
  For example for the font size: ~(set-face-attribute 'default nil :height 100 )~
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/.emacs-local")
    (load "~/.emacs-local"))
#+END_SRC

In my configuration I have some parts that are mac or linux specific.
Those variables make it easier to apply those env specific setup.
#+begin_src emacs-lisp
  (setq *is-linux* (string-equal system-type "gnu/linux"))
  (setq *is-mac* (string-equal system-type "darwin"))
#+end_src

Where to find additional lisp files.
#+begin_src emacs-lisp
  (let ((default-directory  "~/.emacs.d/site-lisp/"))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
#+end_src

Keymap where i store my global keybindings.
It gives priority to my keybindings over ones in major and minor
modes.
Without this, /aggressive/ minor and major modes tend to override my
keybindings.
#+begin_src emacs-lisp
  (defvar my-keys-minor-mode-map (make-keymap) "my-keys-minor-mode keymap.")
  (define-minor-mode my-keys-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    t " my-keys" 'my-keys-minor-mode-map)
  (my-keys-minor-mode 1)

  (defadvice load (after give-my-keybindings-priority)
    "Try to ensure that my keybindings always have priority."
    (if (not (eq (car (car minor-mode-map-alist)) 'my-keys-minor-mode))
        (let ((mykeys (assq 'my-keys-minor-mode minor-mode-map-alist)))
          (assq-delete-all 'my-keys-minor-mode minor-mode-map-alist)
          (add-to-list 'minor-mode-map-alist mykeys))))
  (ad-activate 'load)
#+end_src
* Cute functions
  #+begin_src emacs-lisp
    (defun sudo ()
      "Use TRAMP to `sudo' the file for current buffer."
      (interactive)
      (when buffer-file-name
        (find-alternate-file
         (concat "/sudo:root@localhost:"
                 buffer-file-name))))

    (defun org-strike-header ()
      "Strikes current org-header using + markers."
      (interactive)
      (beginning-of-line)
      (re-search-forward "\*+ ")
      (insert "+")
      (end-of-line)
      (insert "+"))

    (defun my-reload-dir-locals-for-current-buffer ()
      "Reloads dir locals for the current buffer."
      (interactive)
      (let ((enable-local-variables :all))
        (hack-dir-local-variables-non-file-buffer)))

    (defun my-reload-dir-locals-for-all-buffer-in-this-directory ()
      "For every buffer with the same `default-directory` as the current buffer's, reload dir-locals."
      (interactive)
      (let ((dir default-directory))
        (dolist (buffer (buffer-list))
          (with-current-buffer buffer
            (when (equal default-directory dir))
            (my-reload-dir-locals-for-current-buffer)))))

    (defun filepath-with-line-number-for-current-buffer ()
      "Return a string with Buffer-file-name:line-number.
           Make it easier to prepare commands for tools like rspec"
      (interactive)
      (concat (buffer-file-name) ":" (number-to-string (line-number-at-pos))))

    (defun add-date-to-filename ()
      "Add current date in front of filename for current buffer."
      (interactive)
      (let* ((date (format-time-string "%Y-%m-%d"))
             (buffer-file (buffer-file-name))
             (new-file-name (concat (file-name-directory buffer-file)
                                    date
                                    "-"
                                    (file-name-nondirectory buffer-file)))
             )
        (rename-file buffer-file new-file-name)
        (set-visited-file-name new-file-name)
        (save-buffer)))

    (defun toggle-html-export-on-save ()
      "Enable or disable export HTML when saving current buffer."
      (interactive)
      (when (not (eq major-mode 'org-mode))
        (error "Not an org-mode file!"))
      (if (memq 'org-html-export-to-html after-save-hook)
          (progn (remove-hook 'after-save-hook 'org-html-export-to-html t)
                 (message "Disabled org html export on save"))
        (add-hook 'after-save-hook 'org-publish-current-file nil t)
        (set-buffer-modified-p t)
        (message "Enabled org html export on save")))
  #+end_src

* Initialize Packages
  #+begin_src emacs-lisp
    (setq package-archives
          '(("melpa"       . "http://melpa.milkbox.net/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")
            ("gnu"         . "http://elpa.gnu.org/packages/")))

    (setq package-user-dir (concat user-emacs-directory "elpa"))

    (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))

    (defun require-package (package &optional min-version)
      "Ask elpa to install given PACKAGE. You can specify a MIN-VERSION for your PACKAGE."
      (unless (package-installed-p package min-version)
        (package-install package)))

    (require-package 'use-package)
    (require 'use-package)
    (setq use-package-always-ensure t)
  #+end_src

  Show loading time in *messages* buffer. Makes it easier to optimize
  emacs dotfiles
  #+begin_src emacs-lisp
    (defun sanityinc/time-subtract-millis (b a)
      (* 1000.0 (float-time (time-subtract b a))))

    (defvar sanityinc/require-times nil
      "A list of (FEATURE . LOAD-DURATION).
    LOAD-DURATION is the time taken in milliseconds to load FEATURE.")

    (defadvice require (around sanityinc/build-require-times (feature &optional filename noerror) activate)
      "Note in `sanityinc/require-times' the time taken to require each feature."
      (let* ((already-loaded (memq feature features))
             (require-start-time (and (not already-loaded) (current-time))))
        (prog1
            ad-do-it
          (when (and (not already-loaded) (memq feature features))
            (let ((time (sanityinc/time-subtract-millis (current-time) require-start-time)))
              (add-to-list 'sanityinc/require-times
                           (cons feature time)
                           t))))))

    (defun sanityinc/show-init-time ()
      (message "init completed in %.2fms"
               (sanityinc/time-subtract-millis after-init-time before-init-time)))

    (add-hook 'after-init-hook 'sanityinc/show-init-time)
  #+end_src
* Vim / Evil
  Awesome [[https://github.com/noctuid/evil-guide][Evil Guide]]
  #+begin_src emacs-lisp
        (use-package evil
          :ensure t
          :init
          (setq evil-toggle-key "C-`")          ;switch between evil and emacs mode
          (setq evil-mode-line-format nil)
          :config

          (evil-mode 1)
          (use-package key-chord
            :config
            (key-chord-mode 1)
            (key-chord-define evil-insert-state-map  "jk" 'evil-normal-state))

          (use-package evil-surround
            :config
            (global-evil-surround-mode 1))

          (use-package evil-commentary
            :diminish evil-commentary-mode
            :config
            (evil-commentary-mode))

          (use-package evil-visualstar
            :config
            (global-evil-visualstar-mode t))

          (use-package evil-indent-plus
            :config
            (evil-indent-plus-default-bindings))

          (use-package evil-matchit
            :config
            (global-evil-matchit-mode 1))

          (use-package evil-search-highlight-persist
            :config
            (global-evil-search-highlight-persist t))

          (evil-set-initial-state 'deft-mode 'insert)
          (evil-set-initial-state 'dired-mode 'emacs)
          (evil-set-initial-state 'magit-mode 'emacs)

          (add-hook 'with-editor-mode-hook 'evil-insert-state)
          (evil-define-key 'insert deft-mode-map (kbd "C-p") 'previous-line)
          (evil-define-key 'insert deft-mode-map (kbd "C-n") 'next-line)

      (evil-define-key 'insert lisp-interaction-mode-map (kbd "C-j") 'eval-print-last-sexp)
      (evil-ex-define-cmd "W" 'save-buffer))
  #+end_src
* Better Defaults
  I like setting the path manually as other solutions like ~exec-path-from-shell~
  slow down my emacs.
  #+begin_src emacs-lisp
    (let (home-folder (getenv "HOME"))
      (setenv "PATH" (concat (getenv "HOME") "/.config/yarn/global/node_modules/.bin/:"
                             (getenv "HOME") "/.local/bin/:"
                             (getenv "HOME") "/work/dox-compose/bin/:"
                             (getenv "HOME") "/.rbenv/shims:"
                             (getenv "HOME") "/.rbenv/bin:"
                             (getenv "HOME") "/.fzf/bin:"
                             "/usr/local/opt/node@10/bin:"
                             (getenv "PATH"))))

    (setq exec-path '("~/.config/yarn/global/node_modules/.bin/"
                      "/usr/local/opt/node@10/bin/"
                      "~/.local/bin"
                      "~/bin"
                      "~/work/dox-compose/bin/"
                      "~/.rbenv/bin/"
                      "~/.rbenv/shims/"
                      "~/dotfiles/bin/"
                      "~/.fzf/bin"
                      "/usr/local/bin/"
                      "/usr/local/sbin/"
                      "/usr/bin/"))
    (when *is-mac*
      (add-to-list 'exec-path "/usr/local/opt/coreutils/libexec/gnubin"))
  #+end_src

  #+begin_src emacs-lisp
    (setq inhibit-startup-message t)
    (setq delete-by-moving-to-trash t)
    (setq tab-always-indent 'complete)
    ;; show end of buffer on left fringe
    (setq-default default-indicate-empty-lines nil)
    (make-variable-buffer-local 'compile-command)
    (defalias 'yes-or-no-p 'y-or-n-p)
    (setq ring-bell-function 'ignore)

    (setq backup-by-copying t      ; don't clobber symlinks
          backup-directory-alist
          '((".*" . "~/.local/share/emacs-saves"))    ; don't litter my fs tree
          delete-old-versions t
          kept-new-versions 6
          kept-old-versions 2
          auto-save-default t ;files starting with # are generated by autosave
          auto-save-timeout 60 ; number of seconds before auto-saving
          auto-save-interval 200 ; number of keystrokes before auto-saves
          version-control t) ; use versioned backups
    (setq create-lockfiles nil)
    (setq auto-save-file-name-transforms
          `((".*" ,"~/.local/share/emacs-saves" t)))

    ;; if file has no change, just load any changes
    ;; coming from an external process
    (setq global-auto-revert-non-file-buffers t)
    (global-auto-revert-mode 1)

    ;; sentences end with one space after point
    (setq sentence-end-double-space nil)

    ;;; replace selected text when typing
    (pending-delete-mode 1)

    (prefer-coding-system 'utf-8)
    (modify-coding-system-alist 'process "\\*compilation\\*\\'"   'utf-8)
  #+end_src

  I want error highlights and error bindings in shell modes too.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'shell-mode-hook 'compilation-shell-minor-mode)
  #+END_SRC

  ~C-c C-w~ to copy regex to something usable with emacs-lisp
  ~C-c C-q~ to quit re-builder and to remove highlights
  #+BEGIN_SRC emacs-lisp
  ( require 're-builder)
  (setq reb-re-syntax 'string)
  #+END_SRC

** tabs and whitespace
   By default I disable tabs. In addition I use ~whitespace-mode~
   because sometimes when copy pasting code from external sources
   those external sources have tabs. I want to see those tabs to
   remove them.

   I don't use the ~global-whitespace-mode~ because some emacs mode
   like ~magit~ use tabs.

   You can remove all tabs from your buffer with ~untabify~
   #+begin_src emacs-lisp
     (setq-default
      indent-tabs-mode nil    ;no tabs
      c-basic-offset 2)
     (setq-default whitespace-style '(face trailing tabs tab-mark))
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+end_src


** Recent files
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 50)
(setq recentf-max-saved-items 50)
#+END_SRC
* Dired
  #+begin_src emacs-lisp
    (setq ls-lisp-use-insert-directory-program t) ;same ls-lisp for Dired regardless of the platform
    (setq dired-listing-switches "-alh")
    ;; on mac there is some weird prefixing going on for GNU Tools like ls.
    ;; I favor GNU ls over MacOSX default ls
    (when *is-mac*
      (setq insert-directory-program "gls"))

    (require 'dired )
    (defun my-dired-mode-setup ()
      "to be run as hook for `dired-mode'."
      (dired-hide-details-mode 1))
    (add-hook 'dired-mode-hook 'my-dired-mode-setup)

    (put 'dired-find-alternate-file 'disabled nil)
    (setq dired-dwim-target t)
    (add-hook 'dired-load-hook
              (lambda ()
                (load "dired-x")
                ;; Set dired-x global variables here.  For example:
                ;; (setq dired-guess-shell-gnutar "gtar")
                ;; (setq dired-x-hands-off-my-keys nil)
                (setq dired-recursive-copies (quote always)) ; ‚Äúalways‚Äù means no asking
                (setq dired-recursive-deletes (quote top)) ; ‚Äútop‚Äù means ask once
                ))

    (eval-after-load "dired"
      '(progn
         (define-key dired-mode-map "-" 'dired-up-directory)
         (define-key dired-mode-map (kbd "C-u k") 'dired-kill-subdir)
         (define-key dired-mode-map (kbd "SPC") nil)
         (define-key dired-mode-map (kbd "/") 'swiper)
         (define-key dired-mode-map (kbd "j") 'dired-next-line)
         (define-key dired-mode-map (kbd "k") 'dired-previous-line)
         (evil-define-key 'normal dired-mode-map
           "gg" 'evil-goto-first-line
           "^" '(lambda () (interactive) (find-alternate-file "..")))))
  #+end_src
* Search
#+begin_src emacs-lisp
  (use-package rg)
#+end_src
* GUI
  #+begin_src emacs-lisp
    (blink-cursor-mode 0)
    (column-number-mode)

    (electric-indent-mode t)
    (electric-pair-mode t)
    (defun pvj/inhibit-electric-pair-mode (char)
      (minibufferp))

    (setq electric-pair-inhibit-predicate #'pvj/inhibit-electric-pair-mode)

    ;; wrap lines when they reach the end of buffer
    ;; trying to toggle this only manually to see if i like it
    ;; (global-visual-line-mode)

    ;; file path in frame title
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b"))))

    (show-paren-mode 1)

    ;; makes fringe big enough on linux with HDPI
    (fringe-mode 20)

    ;; show in mode bar the current function
    (require 'which-func)
    (which-function-mode t)
  #+end_src

   #+BEGIN_SRC emacs-lisp
   (use-package diminish
     :config
     (diminish 'undo-tree-mode)
     (diminish 'auto-fill-function)
     (diminish 'my-keys-minor-mode)
     (diminish 'eldoc-mode))
   #+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package posframe)
#+END_SRC

** Colors
   Changes modeline color depending on Evil state, if buffer is
   modifier etc...
   #+begin_src emacs-lisp
    (add-to-list 'default-frame-alist '(background-color . "#f1f2f1"))
    (add-to-list 'default-frame-alist '(foreground-color . "#000000"))

       (lexical-let ((default-color (cons (face-background 'mode-line)
                                        (face-foreground 'mode-line))))
       (add-hook 'post-command-hook
                 (lambda ()
                   (let ((color (cond ((minibufferp) default-color)
                                      ((evil-emacs-state-p)  '("#ffa2cb" . "#4c4e56"))
                                      ((evil-visual-state-p) '("#adcff1" . "#4c4e56"))
                                      ((evil-insert-state-p)  '("#97d88a" . "#4c4e56"))
                                      ((buffer-modified-p)   '("#f79b2f" . "#4c4e56"))
                                      (t default-color)))
                         )

                     (set-face-attribute 'mode-line nil :box `(:line-width 2 :color ,(car color)))
                     (set-face-background 'mode-line (car color))
                     (set-face-foreground 'mode-line-buffer-id (cdr color))
                     (set-face-foreground 'mode-line (cdr color))))))

   #+end_src
** Color reference
*** Pantone
    #fff166 101U
    #fccf61 128u
    #f79b2f 130u
    #c97f3a 145u
    #ffa2cb 210u
    #f56d9e 213u
    #dcc6ea 263u
    #bfa1e3 264u
    #9d7ad2 265u
    #adcff1 277u
    #7ab1e8 284u
    #5b8edb 279u
    #8eddeb 304u
    #00b4e4 395u
    #93e8d3 331u
    #97d88a 358u
    #5cb860 360u
    #56944f 362u
    #f1f2f1 11-0601 tpx
    #e8eae8 11-4800 tpx
    #dad9d6 cool g r a y 1 u
    #c5c5c5 cool g r a y 3 u
    #adaeb0 cool g r a y 5 u
    #939598 cool g r a y 8 u

    pastel
    #e4f4e9 9063u
    #c5f2e6 9520u
    #ffcfd8 9284u

    #69615f 440u
    #4c4e56 black7u
    #885a61 195u
    #f65058 r e d 032u
    #bc3e44 3517u
    #34855b 348u
    #546758 350u
    #4982cf 285u
    #3a499c Reflex B l u e U
    #65428a medium p u r p l e
* Navigation
** Search Everything
   #+begin_src emacs-lisp
               (use-package counsel
                 :bind (("M-x" . counsel-M-x)
                        ("C-x C-f" . counsel-find-file)
                        ("<f1> f" . counsel-describe-function)
                        ("<f1> v" . counsel-describe-variable)
                        ("<f1> l" . counsel-find-library)
                        ("<f2> i" . counsel-info-lookup-symbol)
                        ("<f2> u" . counsel-unicode-char)
                        ("C-c g" . counsel-git)
                        ("C-c j" . counsel-git-grep)
                        ("C-c k" . counsel-rg)
                        ("C-x l" . counsel-locate)
                        :map minibuffer-local-map
                        ("C-r" . counsel-minibuffer-history)
                        :map my-keys-minor-mode-map
                        ("C-c r" . counsel-recentf)
                        ("C-c f" . counsel-rg)
                        ("C-c i" . counsel-imenu)
                        ("C-c b" . counsel-ibuffer)
                        ("C-c m" . counsel-bookmark))
                 :init
                 (setq counsel-git-cmd "rg --files")
                 (setq counsel-rg-base-command
                       "rg --smart-case -M 120 --hidden --no-heading --line-number --color never %s .")

                 )

     (eval-after-load "counsel" '(progn
                                   (defun counsel-imenu-categorize-functions (items)
                                     "Categorize all the functions of imenu."
                                     (let ((fns (cl-remove-if #'listp items :key #'cdr)))
                                       (if fns
                                           (nconc (cl-remove-if #'nlistp items :key #'cdr)
                                                  `((":" ,@fns)))
                                         items)))))

     (use-package ivy
       :diminish ivy-mode
       :bind (("C-s" . swiper)
              :map my-keys-minor-mode-map
              ("C-c s r" . ffip-ivy-resume)
              ("C-c v" . ivy-push-view)
              ("C-c V" . ivy-pop-view)
              :map evil-normal-state-map
              ("/" . swiper))
       :init
       (setq ivy-use-selectable-prompt t)
       ;; enable bookmarks and recent-f
       (setq ivy-use-virtual-buffers t)
       (setq enable-recursive-minibuffers t)
       (setq ivy-initial-inputs-alist nil)
       (setq counsel-grep-base-command
             "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
       (setq ivy-re-builders-alist
             '((t . ivy--regex-plus)))
       :config
       (use-package ivy-hydra)
       (ivy-mode 1)
       (defun ivy-switch-buffer-occur ()
         "Occur function for `ivy-switch-buffer' using `ibuffer'."
         (ibuffer nil (buffer-name) (list (cons 'name ivy--old-re))))
       (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))
   #+end_src

** Windows
   #+BEGIN_SRC emacs-lisp
     (define-key my-keys-minor-mode-map (kbd "C-h") 'evil-window-left)
     (define-key my-keys-minor-mode-map (kbd "C-j") 'evil-window-down)
     (define-key my-keys-minor-mode-map (kbd "C-k") 'evil-window-up)
     (define-key my-keys-minor-mode-map (kbd "C-l") 'evil-window-right)

     (define-key my-keys-minor-mode-map (kbd "C-w \\") 'evil-window-vsplit)
     (define-key my-keys-minor-mode-map (kbd "C-w -") 'evil-window-split)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :bind (:map my-keys-minor-mode-map
              ("C-;" . avy-goto-char-timer)))
   #+END_SRC
* Notes
  #+begin_src emacs-lisp
    (use-package deft
      :bind (:map my-keys-minor-mode-map
             ("C-c n" . deft))
      :init
      (setq deft-extensions '("txt" "tex" "org"))
      (setq deft-directory "~/Dropbox/org/")
      (setq deft-use-filename-as-title t)
      (setq deft-use-filter-string-for-filename t)
      (setq deft-default-extension "org")
      (setq deft-recursive t))
  #+end_src
* Magit
#+begin_src emacs-lisp
  (use-package forge
    :after magit)

  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
  (setq ediff-split-window-function 'split-window-vertically)

  (use-package magit
    :bind (:map my-keys-minor-mode-map
                ("C-c gs" . magit-status)
                ("C-c gc" . magit-commit)
                ("C-c gp" . magit-push-current)
                ("C-c gf" . magit-file-dispatch))
    :init
    (setq magit-commit-show-diff nil
          magit-revert-buffers 1)
    :config
    (use-package fullframe
      :config
      (fullframe magit-status magit-mode-quit-window))

    (with-eval-after-load 'magit
      (define-key magit-status-mode-map (kbd "SPC") nil)
      ))

  (use-package diff-hl
    :config
    (add-hook 'prog-mode-hook 'diff-hl-mode)
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

  (use-package git-link
    :bind (:map my-keys-minor-mode-map
                ("C-c gl" . git-link)))

  (use-package git-timemachine
    :bind (:map my-keys-minor-mode-map
                ("C-c gt" . git-timemachine-toggle))
    :config
    (defadvice git-timemachine-mode (after git-timemachine-change-to-emacs-state activate compile)
      "when entering git-timemachine mode, change evil normal state to emacs state"
      (if (evil-normal-state-p)
          (evil-emacs-state)
        (evil-normal-state)))

    (ad-activate 'git-timemachine-mode))

  (defun ab-run-gitsh ()
    "Start gitsh in current git project. Uses st as a terminal."
    (interactive)
    (let ((default-directory (locate-dominating-file (buffer-file-name) ".gitignore")))
      (start-process "gitsh" nil "st" "-g" "120x70" "-c" "scratch-term" "gitsh")))
  (define-key my-keys-minor-mode-map (kbd "C-c gg") 'ab-run-gitsh)
#+end_src
* Projects
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind (:map my-keys-minor-mode-map
           ("C-c p" . projectile-command-map))
    :init
    (setq projectile-switch-project-action 'projectile-dired)
    :config
    (projectile-mode t)

    (projectile-register-project-type 'npm '("package.json")
                                      :compile "npm install"
                                      :test "npm test"
                                      :run "npm start"
                                      :test-suffix ".spec"))
#+END_SRC

#+begin_src emacs-lisp
  (use-package dumb-jump
    :bind (:map evil-normal-state-map
                ("gd" . dumb-jump-go)
                ("gD" . dumb-jump-go-other-window))
    :init
    (setq dumb-jump-selector 'ivy)
    :config
    (add-hook 'dumb-jump-after-jump-hook
              (defun abo-dumb-jump-pulse-line ()
                (pulse-momentary-highlight-one-line (point)))))
#+end_src

#+begin_src emacs-lisp
  (use-package counsel-etags
    :bind (:map evil-normal-state-map
                ("gt" . counsel-etags-find-tag-at-point)
                ("gT" . counsel-etags-find-tag)))
#+end_src
* Org
  #+begin_src emacs-lisp
    (use-package htmlize)

    (setq org-directory (expand-file-name "~/Dropbox/org"))
    (setq org-default-notes-file (concat org-directory "/GTD.org"))
    (define-key my-keys-minor-mode-map "\C-cc" 'org-capture)
    (define-key my-keys-minor-mode-map "\C-cl" 'org-store-link)

    (defun draft-org-files ()
      (directory-files-recursively "~/Dropbox/org/writing/" ".*\.org"))

    (setq org-refile-targets '((nil :maxlevel . 3)
                               (org-agenda-files :maxlevel . 3)
                               (draft-org-files :maxlevel . 3)))
    (setq org-outline-path-complete-in-steps nil)         ; Refile in a single go
    (setq org-refile-use-outline-path 'file)                  ; Show full paths for refiling
    (setq org-refile-allow-creating-parent-nodes 'confirm)

    (add-hook 'org-mode-hook 'turn-on-auto-fill)

    (setq org-capture-templates
          '(("g" "GTD" entry (file+headline "~/Dropbox/org/GTD.org" "Inbox") "* %?\n")
            ("t" "TDD" checkitem (file "~/Dropbox/org/tdd.org"))))

    (add-hook 'org-capture-mode-hook 'evil-insert-state)

    (setq org-use-speed-commands nil)

    (evil-define-key 'normal org-mode-map
      (kbd "M-l") 'org-shiftmetaright
      (kbd "M-h") 'org-shiftmetaleft
      (kbd "M-k") 'org-move-subtree-up
      (kbd "M-j") 'org-move-subtree-down
      (kbd "M-p") 'org-publish-current-project
      "<" 'org-clock-in
      ">" 'org-clock-out
      "4" 'org-archive-subtree
      "2" 'counsel-org-tag
      "3" 'org-refile
      "t" 'org-todo)

    (add-to-list 'org-modules "org-habit")
    (setq org-log-into-drawer t)

    (setq org-todo-keywords
          '((sequence "TODO" "PR" "QA" "|" "DONE(!)" "CANCELED")))
  #+end_src
** org-babel
   #+begin_src emacs-lisp
   (require 'ob-js)
   (org-babel-do-load-languages 'org-babel-load-languages
                                '((shell . t)))
   #+end_src
** org-capture
   #+begin_src emacs-lisp
  ;; emacsclient -ca "" --frame-parameters='(quote (name . "global-org-capture"))' -e "(counsel-org-capture)"
  ;; https://cestlaz.github.io/posts/using-emacs-24-capture-2/
  ;; Bind Key to: emacsclient -e "(make-capture-frame)"
  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "global-org-capture" (frame-parameter nil 'name))
        (progn
          (delete-frame))))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "global-org-capture" (frame-parameter nil 'name))
        (progn
          (delete-frame))))

  ;; make the frame contain a single window. by default org-capture
  ;; splits the window.
  (add-hook 'org-capture-mode-hook
            'delete-other-windows)
   #+end_src
** org-publish
   #+begin_src emacs-lisp
     (setq
      time-stamp-active t
      time-stamp-line-limit 30     ; check first 30 buffer lines for Time-stamp:
      time-stamp-format "%04y-%02m-%02d") ;

     (add-hook 'org-mode-hook
               (lambda ()
                 (setq-local time-stamp-start "Updated on[ 	]+\\\\?[\"<]+")
                 (add-hook 'before-save-hook 'time-stamp nil 'local)))

     (add-hook 'write-file-hooks 'time-stamp) ; update when saving
     (require 'ox-publish)
     (setq system-time-locale "C") ;; make sure time local is in english when exporting
     (setq org-html-validation-link nil)
     (setq org-publish-project-alist
           '(
             ("wiki-files"
              :base-directory "~/Dropbox/wiki"
              :base-extension "org"
              :publishing-directory "~/Dropbox/wiki_published/"
              :recursive t
              :publishing-function org-html-publish-to-html
              :headline-levels 4             ; Just the default for this project.
              :auto-preamble t
              :html-head nil
              :html-head-extra nil
              :body-only nil
              )
             ;; ... add all the components here (see below)...
             ;; ("wiki" :components ("wiki-files"))
             )
           org-export-with-toc nil
           org-html-doctype "html5"
           org-html-head nil
           org-html-head-include-default-style nil
           org-html-head-include-scripts nil
           org-html-html5-fancy t
           org-html-postamble nil
           org-html-indent t)
   #+end_src
  #+begin_src emacs-lisp
    (use-package palimpsest
      :diminish palimpsest-mode
      :config
      (add-hook 'org-mode-hook 'palimpsest-mode))
  #+end_src

  Keep emacs fast with large files.
  #+begin_src emacs-lisp
    (defun check-large-file-hook ()
      "If a file is over a given size, turn off minor modes."
      (when (> (buffer-size) (* 1024 100)) ;; 100K
        (fundamental-mode)
        (font-lock-mode -1)
        (setq buffer-read-only t)
        (buffer-disable-undo)))

    (add-hook 'find-file-hooks 'check-large-file-hook)
  #+end_src

  #+begin_src emacs-lisp
    (defun my-prog-mode-auto-fill-hook ()
      (setq fill-column 80)
      (set (make-local-variable 'comment-auto-fill-only-comments) t)
      (auto-fill-mode t))
    (add-hook 'prog-mode-hook 'my-prog-mode-auto-fill-hook)
  #+end_src

* Clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :mode "\\.clj\\'"
  :config
  (add-hook 'clojure-mode-hook #'subword-mode)
  (use-package cider))
#+END_SRC
* Ruby
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'")

  (use-package ruby-mode
    :mode "\\.rake\\'"
    :mode "Rakefile\\'"
    :mode "\\.gemspec\\'"
    :mode "\\.ru\\'"
    :mode "Gemfile\\'"
    :mode "Guardfile\\'" :mode "Capfile\\'"
    :mode "\\.cap\\'"
    :mode "\\.thor\\'"
    :mode "\\.rabl\\'"
    :mode "Thorfile\\'"
    :mode "Vagrantfile\\'"
    :mode "\\.jbuilder\\'"
    :mode "Podfile\\'"
    :mode "\\.podspec\\'"
    :mode "Puppetfile\\'"
    :mode "Berksfile\\'"
    :mode "Appraisals\\'"
    :mode "\\.rb$"
    :mode "ruby"
    :config

    (add-hook 'ruby-mode-hook 'subword-mode)
    (diminish 'subword-mode)
    (use-package ruby-interpolation)
    (use-package inf-ruby)

    (use-package ruby-end)
    (use-package rspec-mode)

    (use-package ruby-refactor
      :diminish ruby-refactor-mode
      :bind (:map ruby-mode-map
                  ("C-c r m" . ruby-refactor-extract-to-method)
                  ("C-c r c" . ruby-refactor-extract-constant)
                  ("C-c r v" . ruby-refactor-extract-local-variable)
                  ("C-c r l" . ruby-refactor-extract-to-let))
      :config
      (add-hook 'ruby-mode-hook 'ruby-refactor-mode-launch))


    ;; Hitting M-; twice adds an xmpfilter comment. Hitting xmp keybinding will put the output in this comment
    (use-package rcodetools
      :load-path "/site-lisp/rcodetools.el"
      :pin manual
      :ensure nil
      :config
      (defadvice comment-dwim (around rct-hack activate)
        "If comment-dwim is successively called, add => mark."
        (if (and (or (eq major-mode 'enh-ruby-mode)
                     (eq major-mode 'ruby-mode))
                 (eq last-command 'comment-dwim))
            (progn
              (if (eq major-mode 'enh-ruby-mode)
                  (end-of-line))
              (insert "=>"))
          ad-do-it))))
#+END_SRC
* HTML
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.html\\'")

  (use-package emmet-mode
    :diminish emmet-mode
    :config
    (progn
      (evil-define-key 'insert emmet-mode-keymap (kbd "C-j") 'emmet-expand-line)
      (evil-define-key 'emacs emmet-mode-keymap (kbd "C-j") 'emmet-expand-line))

    (add-hook 'css-mode-hook
              (lambda ()
                (emmet-mode)
                (setq emmet-expand-jsx-className? nil)))

    (add-hook 'sgml-mode-hook
              (lambda ()
                (emmet-mode)
                (setq emmet-expand-jsx-className? nil)))

    (add-hook 'web-mode-hook
              (lambda ()
                (emmet-mode))))
#+END_SRC
* CSS
#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :mode "\\.scss\\'")

(use-package sass-mode
  :mode "\\.sass\\'"
  :config
  (add-hook 'sass-mode-hook 'highlight-indent-guides-mode))

(use-package less-css-mode
  :mode "\\.less\\'")
#+END_SRC
* Docker
#+begin_src emacs-lisp
  (use-package docker
   :ensure t
   :bind ("C-c d d". docker)
   :config
      (defadvice docker-image-mode (after docker-image-mode-change-to-emacs-state activate compile)
        "when entering git-timemachine mode, change evil normal state to emacs state"
        (if (evil-normal-state-p)
            (evil-emacs-state)
          (evil-normal-state)))
          )

  ;; (use-package transient)
  ;; (require 'dox-dc)
  ;; (define-key my-keys-minor-mode-map (kbd "C-c d x") (dox-dc))
  ;; (evil-set-initial-state 'dox-dc-mode 'emacs)
#+end_src
* Javascript
#+BEGIN_SRC emacs-lisp
  (require 'compile)
  (setq compilation-error-regexp-alist-alist
        (cons '(node "^\\([a-zA-Z\.0-9\/-]+\\):\\([0-9]+\\)$"
                     1 ;; file
                     2 ;; line
                     )
              compilation-error-regexp-alist-alist))
  (setq compilation-error-regexp-alist
        (cons 'node compilation-error-regexp-alist))
  (add-hook 'js2-mode-hook
            (lambda ()
              (set (make-local-variable 'compile-command)
                   (format "node %s" (file-name-nondirectory buffer-file-name)))))

  (setq js-indent-level 2)

  (use-package js2-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (add-to-list 'auto-mode-alist '("\\.jsx\\'" . js2-mode))
    (use-package js2-refactor
      :init
      (setq js2-skip-preprocessor-directives t)
      :config
      (add-hook 'js2-mode-hook #'js2-refactor-mode)
      (js2r-add-keybindings-with-prefix "C-c r"))

    (use-package js-comint)

    (setq js2-mode-show-parse-errors nil)
    (setq js2-mode-show-strict-warnings nil)

    (setq-default
     ;; js2-mode
     js2-basic-offset 2
     ;; web-mode
     css-indent-offset 2
     web-mode-markup-indent-offset 2
     web-mode-script-padding 0
     web-mode-css-indent-offset 2
     web-mode-style-padding 2
     web-mode-code-indent-offset 2
     web-mode-attr-indent-offset 2)

    (setq js2-highlight-level 3)
    :config
    (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
    (add-hook 'js2-mode-hook (lambda() (subword-mode t)))

    (use-package import-js)

    (use-package js2-refactor)
    (use-package xref-js2)

    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (js2r-add-keybindings-with-prefix "C-c C-r")
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill)

    ;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
    ;; unbind it.
    (define-key js-mode-map (kbd "M-.") nil)

    (add-hook 'js2-mode-hook (lambda ()
                               (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
    (use-package prettier-js
      :config
      (setq prettier-args '(
                            "--trailing-comma" "es5"
                            "--single-quote" "true"
                            )
            prettier-js-command "/usr/local/bin/prettier")
      (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
      (add-hook 'js2-mode-hook 'prettier-js-mode))

    (defun auray-js-mode-hook ()
      (setq imenu-create-index-function 'auray-js-imenu-make-index))
    (add-hook 'js2-mode-hook 'auray-js-mode-hook))


  (defun enable-minor-mode (my-pair)
    "Enable minor mode if filename match the regexp.  MY-PAIR is a cons cell (regexp . minor-mode)."
    (if (buffer-file-name)
        (if (string-match (car my-pair) buffer-file-name)
            (funcall (cdr my-pair)))))

  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.jsx?\\'" . prettier-js-mode))))

  ;; (add-hook 'web-mode-hook #'(lambda ()
  ;;                              (enable-minor-mode
  ;;                               '("\\.vue?\\'" . prettier-js-mode))))

  (add-to-list 'magic-mode-alist '("^import.*React.* from 'react'" . my-jsx-hook) )
  (defun my-jsx-hook ()
    "My Hook for JSX Files"
    (interactive)
    (web-mode)
    (web-mode-set-content-type "jsx")
    (setq imenu-create-index-function 'auray-js-imenu-make-index)
    (flycheck-select-checker 'javascript-eslint)
    (emmet-mode)
    (setq emmet-expand-jsx-className? t)
    (tern-mode t))

  (use-package context-coloring
    :diminish context-coloring-mode
    :bind (:map my-keys-minor-mode-map ("C-c oc" . context-coloring-mode)))

  (use-package json-mode
    :mode "\\.json\\'"
    :mode "\\.eslintrc\\'")

  (use-package coffee-mode
    :mode "\\.coffee\\'"
    :config
    (use-package highlight-indentation)
    (add-hook 'coffee-mode-hook '(lambda () (highlight-indentation-mode)))
    (add-hook 'coffee-mode-hook '(lambda () (subword-mode +1)))
    (custom-set-variables '(coffee-tab-width 2)))

  (use-package typescript-mode
    :mode "\\.ts\\'")
#+END_SRC
** Vue
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.vue\\'"
    :config
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-script-padding 0)
    (defun jjpandari/merge-imenu (index-fun)
      (interactHLL8360CDWG1ive)
      (let ((mode-imenu (funcall index-fun))
            (custom-imenu (imenu--generic-function imenu-generic-expression)))
        (append custom-imenu mode-imenu)))

    (add-hook 'web-mode-hook
              (lambda ()
                (setq imenu-create-index-function (lambda () (jjpandari/merge-imenu 'web-mode-imenu-index)))
                (setq imenu-generic-expression javascript-common-imenu-regex-list))))

#+END_SRC
* Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    (add-hook 'web-mode-hook 'flycheck-mode)
    (add-hook 'js2-mode-hook 'flycheck-mode)
    (defun my/use-eslint-from-node-modules ()
      (let* ((root (locate-dominating-file
                    (or (buffer-file-name) default-directory)
                    "node_modules"))
             (eslint (and root
                          (expand-file-name "node_modules/eslint/bin/eslint.js"
                                            root))))
        (when (and eslint (file-executable-p eslint))
          (setq-local flycheck-javascript-eslint-executable eslint))))
    (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)


  (define-derived-mode cfn-mode yaml-mode
    "Cloudformation"
    "Cloudformation template mode.")
  (add-to-list 'auto-mode-alist '(".template.yaml\\'" . cfn-mode))
  (add-hook 'cfn-mode-hook 'flycheck-mode)
  (flycheck-define-checker cfn-lint
    "A Cloudformation linter using cfn-python-lint.
              See URL 'https://github.com/awslabs/cfn-python-lint'."
    :command ("cfn-lint" "-f" "parseable" source)
    :error-patterns (
                     (warning line-start (file-name) ":" line ":" column
                              ":" (one-or-more digit) ":" (one-or-more digit) ":"
                              (id "W" (one-or-more digit)) ":" (message) line-end)
                     (error line-start (file-name) ":" line ":" column
                            ":" (one-or-more digit) ":" (one-or-more digit) ":"
                            (id "E" (one-or-more digit)) ":" (message) line-end)
                     )
    :modes (cfn-mode))
  (add-to-list 'flycheck-checkers 'cfn-lint))

  (require 'aurayb-narrow-indirect-vue)
  ;; (define-key my-keys-minor-mode-map (kbd "nj") (aurayb-make-narrow-indirect-vue "script" 'js2-mode))
  ;; (define-key my-keys-minor-mode-map (kbd "nh") (aurayb-make-narrow-indirect-vue "template" 'html-mode))
  ;; (define-key my-keys-minor-mode-map (kbd "ns") (aurayb-make-narrow-indirect-vue "style" 'scss-mode))
  ;; (define-key my-keys-minor-mode-map (kbd "nn") '(lambda () (interactive) (pop-to-buffer-same-window (buffer-base-buffer))))
#+END_SRC
* AutoCompletion
#+BEGIN_SRC emacs-lisp
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line))
  (require 'mode-local)
  (setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol))
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-all-abbrevs try-expand-line))
  (require 'mode-local)
  (setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-all-abbrevs try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol))
  (define-key evil-insert-state-map (kbd "s-/") 'hippie-expand)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :config
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil)
  (setq company-show-numbers t)
  (setq company-backends '((company-files company-lsp company-capf company-dabbrev)))

  (define-key evil-insert-state-map (kbd "C-x C-o") 'company-complete)
  (let ((map company-active-map))
    (mapc
     (lambda (x)
       (define-key map (format "%d" x) 'ora-company-number))
     (number-sequence 0 9))
    (define-key map " " (lambda ()
                          (interactive)
                          (company-abort)
                          (self-insert-command 1)))
    (define-key map (kbd "<return>") nil))

  (defun ora-company-number ()
    "Forward to `company-complete-number'.

  Unless the number is potentially part of the candidate.
  In that case, insert the number."
    (interactive)
    (let* ((k (this-command-keys))
           (re (concat "^" company-prefix k)))
      (if (cl-find-if (lambda (s) (string-match re s))
                      company-candidates)
          (self-insert-command 1)
        (company-complete-number (string-to-number k))))))
#+END_SRC
* Snippets
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :demand
    :commands yas-expand-snippet
    :bind (:map my-keys-minor-mode-map
                ("C-c yd" . yas-describe-tables))
    :diminish yas-minor-mode
    :init
    (setq yas-snippet-dirs
          '("~/.emacs.d/snippets"))
    :config
    (yas-global-mode 1)
    (add-hook 'term-mode-hook (lambda()
                                (yas-minor-mode -1))))
#+END_SRC
* Run for mode
#+BEGIN_SRC emacs-lisp
(defun run-for-mode ()
    "Run interactive command for the current buffer programming mode"
    (interactive)
    (cond
     ((equal major-mode 'org-mode)
      (org-babel-execute-src-block))
     ((equal major-mode 'ruby-mode)
      (xmp))
     ((equal major-mode 'enh-ruby-mode)
      (xmp))
     ((equal major-mode 'clojure-mode)
      (cider-eval-defun-at-point))
     ((equal major-mode 'clojurescript-mode)
      (cider-eval-defun-at-point))
     ((or (equal major-mode 'emacs-lisp-mode) (equal major-mode 'lisp-interaction-mode))
      (eval-defun nil))
     ((equal major-mode 'js2-mode)
      (run-node-on-buffer))
     (t (error "No run command for that mode"))))


(defun run-bigger-for-mode ()
    "Run interactive command for the current buffer programming mode"
    (interactive)
    (cond
     ((equal major-mode 'org-mode)
      (org-publish-current-file))
     ((equal major-mode 'ruby-mode)
      (xmp))
     ((equal major-mode 'enh-ruby-mode)
      (xmp))
     ((equal major-mode 'clojure-mode)
      (cider-load-buffer))
     ((equal major-mode 'clojurescript-mode)
      (cider-load-buffer))
     ((or (equal major-mode 'emacs-lisp-mode) (equal major-mode 'lisp-interaction-mode))
      (eval-defun nil))
     ((equal major-mode 'js2-mode)
      (progn
        (js-comint-reset-repl)
        (js-comint-send-buffer)
        (other-window -1)))
     (t (error "No run command for that mode"))))

(define-key my-keys-minor-mode-map (kbd "C-c x") 'run-for-mode)
(define-key my-keys-minor-mode-map (kbd "C-c X") 'run-bigger-for-mode)
#+END_SRC
* Bindings
** General
   Shows key combination helper in minibuffer
   #+begin_src emacs-lisp
     (use-package which-key
       :diminish which-key-mode
       :config
       (which-key-mode))
   #+end_src

   Combined with C-M-c (exit-recursive-edit) allows to stop doing
   something, do something else and come back to it later.
   #+begin_src emacs-lisp
    (define-key my-keys-minor-mode-map (kbd "C-M-e") 'recursive-edit)
   #+end_src

   I use spc as my leader key so I want it available everywhere
   #+begin_src emacs-lisp
  (define-key evil-motion-state-map (kbd "SPC") nil)
   #+end_src

   Make grep buffers writable with ~C-c C-p~. Apply changes with ~C-c C-e~
   #+begin_src emacs-lisp
    ;; makes grep buffers writable and apply the changes to files.
    (use-package wgrep :defer t)
   #+end_src

   #+begin_src emacs-lisp
     (use-package paredit
       :diminish paredit-mode
       :bind (:map my-keys-minor-mode-map
              ("C-)" . paredit-forward-slurp-sexp)
              ("C-}" . paredit-forward-bard-sexp))
       :config
       (add-hook 'emacs-lisp-mode-hook #'paredit-mode))

     (define-key my-keys-minor-mode-map (kbd "C-u") 'evil-scroll-up)

     (use-package expand-region
       :bind (:map my-keys-minor-mode-map ("C-c w" . er/expand-region)))

     (define-key my-keys-minor-mode-map (kbd "C-c a") 'org-agenda)
     (define-key my-keys-minor-mode-map (kbd "C-c R") 'revert-buffer)
     (define-key my-keys-minor-mode-map (kbd "C-c jc") 'org-clock-jump-to-current-clock)
     (define-key my-keys-minor-mode-map (kbd "C-c jd") '(lambda () (interactive) (find-file "~/Dropbox/org/writing/drafts")))
     (define-key my-keys-minor-mode-map (kbd "C-c je") '(lambda () (interactive) (find-file (concat user-emacs-directory "Aurelien.org"))))
     (define-key my-keys-minor-mode-map (kbd "C-c jg") '(lambda () (interactive) (find-file "~/Dropbox/org/GTD.org")))
     (define-key my-keys-minor-mode-map (kbd "C-c jp") '(lambda () (interactive) (find-file "~/projects/")))
     (define-key my-keys-minor-mode-map (kbd "C-c jw") '(lambda () (interactive) (find-file "~/Dropbox/wiki")))
     (define-key my-keys-minor-mode-map (kbd "C-c jj") 'dired-jump)
     (define-key my-keys-minor-mode-map (kbd "C-c k") 'recompile)
     (define-key my-keys-minor-mode-map (kbd "C-c K") 'compile)

     (define-key my-keys-minor-mode-map (kbd "<f5>") 'ispell-buffer)
     (use-package define-word
       :config
       (define-key my-keys-minor-mode-map (kbd "<f6>") 'define-word-at-point))

     (defun lookup-synonyms (word)
       (interactive (list (save-excursion (car (ispell-get-word nil)))))
       (browse-url (format "http://en.wiktionary.org/wiki/%s" word)))

     (define-key my-keys-minor-mode-map (kbd "<f7>") 'lookup-synonyms)
     (define-key my-keys-minor-mode-map (kbd "C-c oh") 'evil-search-highlight-persist-remove-all)
     (defun hide-line-numbers ()
       (interactive)
       (setq display-line-numbers (quote nil)))
     (define-key my-keys-minor-mode-map (kbd "C-c olh") 'hide-line-numbers)
     (defun show-line-numbers ()
       (interactive)
       (setq display-line-numbers (quote absolute)))
     (define-key my-keys-minor-mode-map (kbd "C-c oll") 'show-line-numbers)
     (define-key my-keys-minor-mode-map (kbd "C-c ow") 'visual-line-mode)
     (define-key my-keys-minor-mode-map (kbd "C-c of") 'auto-fill-mode)
     (define-key my-keys-minor-mode-map (kbd "C-c os") 'org-strike-header)
     (define-key my-keys-minor-mode-map (kbd "C-c og") 'global-hl-line-mode)
     (use-package rainbow-mode
       :bind (:map my-keys-minor-mode-map
                   ("C-c or" . rainbow-mode)))
     ;; gives each line only one visual line and don't show a continuation on next line
     (set-default 'truncate-lines t)
     (define-key my-keys-minor-mode-map (kbd "C-c ot") 'toggle-truncate-lines)

     (define-key evil-normal-state-map (kbd "[b") 'previous-buffer)
     (define-key evil-normal-state-map (kbd "]b") 'next-buffer)
     (define-key evil-normal-state-map (kbd "]e") 'next-error)
     (define-key evil-normal-state-map (kbd "[e") 'previous-error)
     (define-key evil-normal-state-map (kbd "<f8>") 'previous-error)
     (define-key evil-normal-state-map (kbd "<f9>") 'next-error)

     (use-package windresize
       :bind (:map evil-normal-state-map
                   ("C-w r" . windresize)))
   #+end_src
** Find file in project
   Here is complete setup you could insert into ~/.emacs.d/init.el,

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; if the full path of current file is under SUBPROJECT1 or SUBPROJECT2
     ;; OR if I'm reading my personal issue track document,
     (defun my-setup-develop-environment ()
       (interactive)
       (when (ffip-current-full-filename-match-pattern-p "\\(PROJECT_DIR\\|issue-track.org\\)")
         ;; Though PROJECT_DIR is team's project, I care only its sub-directory "subproj1""
         (setq-local ffip-project-root "~/projs/PROJECT_DIR/subproj1")
         ;; well, I'm not interested in concatenated BIG js file or file in dist/
         (setq-local ffip-find-options "-not -size +64k -not -iwholename '*/dist/*'")
         ;; for this project, I'm only interested certain types of files
         (setq-local ffip-patterns '("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
         ;; maybe you want to search files in `bin' directory?
         (setq-local ffip-prune-patterns (delete "*/bin/*" ffip-prune-patterns))
         ;; exclude `dist/' directory
         (add-to-list 'ffip-prune-patterns "*/dist/*"))
       ;; insert more WHEN statements below this line for other projects
       )

     ;; most major modes inherit from prog-mode, so below line is enough
     (add-hook 'prog-mode-hook 'my-setup-develop-environment)
   #+END_SRC

   All variables may be overridden on a per-directory basis in your
   .dir-locals.el. See (info ‚Äú(Emacs) Directory Variables‚Äù) for
   details.

   You can place .dir-locals.el into your project root directory.

   A sample .dir-locals.el,

   #+BEGIN_SRC emacs-lisp :tangle no
     ((nil . ((ffip-project-root . "~/projs/PROJECT_DIR")
              ;; ignore files bigger than 64k and directory "dist/" when searching
              (ffip-find-options . "-not -size +64k -not -iwholename '*/dist/*'")
              ;; only search files with following extensions
              (ffip-patterns . ("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
              (eval . (progn
                        (require 'find-file-in-project)
                        ;; ignore directory ".tox/" when searching
                        (setq ffip-prune-patterns `("*/.tox/*" ,@ffip-prune-patterns))
                        ;; Do NOT ignore directory "bin/" when searching
                        (setq ffip-prune-patterns `(delete "*/bin/*" ,@ffip-prune-patterns))))
              )))
   #+END_SRC

   To install fd (rust replacement for find), download it
   [[https://github.com/sharkdp/fd/releases][here]] and run ~sudo dpkg -i fd_7.0.0_amd64.deb~. You can then choose
   to use `fd` instead of find.
   #+begin_src emacs-lisp
     (use-package find-file-in-project
       :bind (:map  my-keys-minor-mode-map
                    ("C-c t" . find-file-in-project)
                    ("C-c T" . find-file-in-project-by-selected)
                    :map evil-normal-state-map
                    ("gf" . find-file-in-project-at-point))
       :config
       (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.png")) ffip-ignore-filenames))
       (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpg")) ffip-ignore-filenames))
       (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpeg")) ffip-ignore-filenames))
       (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.gif")) ffip-ignore-filenames))
       (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.bmp")) ffip-ignore-filenames))
       (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.ico")) ffip-ignore-filenames))
       (setq ffip-prefer-ido-mode nil)
       (setq ffip-use-rust-fd t)
       (add-to-list 'ffip-prune-patterns "*/.git/*")
       (add-to-list 'ffip-prune-patterns "*/dist/*")
       (add-to-list 'ffip-prune-patterns "*/.idea/*")
       (add-to-list 'ffip-prune-patterns "*/.nuxt/*")
       (add-to-list 'ffip-prune-patterns "*/spec/coverage/*")
       (add-to-list 'ffip-prune-patterns "node_modules/*"))
   #+end_src
** Drag stuff
   #+begin_src emacs-lisp
     (use-package drag-stuff
       :diminish t
       :bind (:map my-keys-minor-mode-map
              ("C-M-<up>" . drag-stuff-up)
              ("C-M-<down>" . drag-stuff-down))
       :config
       (drag-stuff-global-mode t))
   #+end_src
