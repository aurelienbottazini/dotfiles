#+TITLE: AurÃ©lien Bottazini's Emacs configuration
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :results silent :tangle yes

I like to use a dark background.
This is setup on my terminal through the terminal color settings.
However if I use the Emacs GUI I need to make sure the colors match
what my terminal settings are.
#+begin_src emacs-lisp
(when (display-graphic-p)
  (set-face-background 'default "#282c34")
  (set-face-foreground 'default "#dcdfe4"))
#+end_src

I  use Vim keybindings everywhere except with special modes
like Magit, Dired... I setup those special modes to start with Emacs
keybindings by default. If for any reason I encounter other modes
where the Vim keybindings are interfering too much, I can disable the
Vim keybindings with ~evil-toggle-key~
#+BEGIN_SRC emacs-lisp
(setq evil-toggle-key "C-c e")
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun my-prog-mode-auto-fill-hook ()
  (setq fill-column 80)
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))
(add-hook 'prog-mode-hook 'my-prog-mode-auto-fill-hook)
#+END_SRC

* Setup
  It is important to load custom settings first. Those are the ones
  managed by Emacs through customization menus. They can impact the
  loading of other packages.
  #+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)
  #+end_src

  As I work on different computers, I need slightly different
  settings. Instead of embedding machine specific code through
  conditionals, I use a file to load machine specifics global
  variables that are used in other parts of this configuration. I have
  a small convention for the names. I surround them with double stars
  and the name starts with local. Ex: ~(setq **local-my-variable**
  "foo/bar")~.
  #+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/.emacs.d/.emacs-local")
    (load "~/.emacs.d/.emacs-local"))
  #+END_SRC

  I keep elisp I write inside the site-lisp directory. The files
  inside that directory are automatically added to the Emacs load-path.
  #+begin_src emacs-lisp
  (let ((default-directory  "~/.emacs.d/site-lisp/"))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
  #+end_src

  I use a special keymap ~my-keys-minor-mode-map~ where i store my global keybindings.
  This is mainly to use a ~defadvice~ to make sure that any key I
  define in my keymap as priority over ones defined elsewhere by
  built-in Emacs modes or 3rd party packages
  #+begin_src emacs-lisp
  (defvar my-keys-minor-mode-map (make-keymap) "my-keys-minor-mode keymap.")
  (define-minor-mode my-keys-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    t " my-keys" 'my-keys-minor-mode-map)
  (my-keys-minor-mode 1)

  (defadvice load (after give-my-keybindings-priority)
    "Try to ensure that my keybindings always have priority."
    (if (not (eq (car (car minor-mode-map-alist)) 'my-keys-minor-mode))
        (let ((mykeys (assq 'my-keys-minor-mode minor-mode-map-alist)))
          (assq-delete-all 'my-keys-minor-mode minor-mode-map-alist)
          (add-to-list 'minor-mode-map-alist mykeys))))
  (ad-activate 'load)
  #+end_src

* Package library initialization
  #+begin_src emacs-lisp
    (setq package-archives
          '(("melpa"       . "http://melpa.milkbox.net/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")
            ("gnu"         . "http://elpa.gnu.org/packages/")))

    (setq package-user-dir (concat user-emacs-directory "elpa"))

    (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))

    (defun require-package (package &optional min-version)
      "Ask elpa to install given PACKAGE. You can specify a MIN-VERSION for your PACKAGE."
      (unless (package-installed-p package min-version)
        (package-install package)))

    (require-package 'use-package)
    (require 'use-package)
    (setq use-package-always-ensure t)
  #+end_src

  You can get the time it took for emacs to start with.
  It ~c-c c-c~ and it will show in the echo area.
  #+begin_src emacs-lisp :tangle no
  (emacs-init-time)
  #+end_src

* Local variables
  Local variables are useful to customize your settings for different
  projects/directories. The built in ~make-local-variable~ is
  convenient in helping you create those variables.

  I find annoying when I edit those local variables
  that they are not picked up automatically for open buffers. Those two
  functions help me with the reloading of those locals.
  #+BEGIN_SRC emacs-lisp
    (defun my-reload-dir-locals-for-current-buffer ()
      "Reloads dir locals for the current buffer."
      (interactive)
      (let ((enable-local-variables :all))
        (hack-dir-local-variables-non-file-buffer)))

    (defun my-reload-dir-locals-for-all-buffer-in-this-directory ()
      "For every buffer with the same `default-directory` as the current buffer's, reload dir-locals."
      (interactive)
      (let ((dir default-directory))
        (dolist (buffer (buffer-list))
          (with-current-buffer buffer
            (when (equal default-directory dir))
            (my-reload-dir-locals-for-current-buffer)))))
  #+END_SRC

* Utility functions
  #+begin_src emacs-lisp
    (defun sudo ()
      "Use TRAMP to `sudo' the file for current buffer."
      (interactive)
      (when buffer-file-name
        (find-alternate-file
         (concat "/sudo:root@localhost:"
                 buffer-file-name))))

    (defun filepath-with-line-number-for-current-buffer ()
      "Return a string with Buffer-file-name:line-number.
           Make it easier to prepare commands for tools like rspec"
      (interactive)
      (concat (buffer-file-name) ":" (number-to-string (line-number-at-pos))))

    (defun add-date-to-filename ()
      "Add current date in front of filename for current buffer. This is useful with some
      Blog tools like Jekyll to publish new articles."
      (interactive)
      (let* ((date (format-time-string "%Y-%m-%d"))
             (buffer-file (buffer-file-name))
             (new-file-name (concat (file-name-directory buffer-file)
                                    date
                                    "-"
                                    (file-name-nondirectory buffer-file)))
             )
        (rename-file buffer-file new-file-name)
        (set-visited-file-name new-file-name)
        (save-buffer)))

    (defun toggle-html-export-on-save ()
      "Enable or disable HTML export when saving current org buffer."
      (interactive)
      (when (not (eq major-mode 'org-mode))
        (error "Not an org-mode file!"))
      (if (memq 'org-html-export-to-html after-save-hook)
          (progn (remove-hook 'after-save-hook 'org-html-export-to-html t)
                 (message "Disabled org html export on save"))
        (add-hook 'after-save-hook 'org-publish-current-file nil t)
        (set-buffer-modified-p t)
        (message "Enabled org html export on save")))
  #+end_src

* Better Defaults
  I like setting the path manually as other solutions like ~exec-path-from-shell~
  slow down my Emacs.

  #+begin_src emacs-lisp
    (setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/adoptopenjdk-12.0.2.jdk/Contents/Home")
    (let ((home-folder (getenv "HOME")))
      (setenv "PATH" (concat
                             "/home/linuxbrew/.linuxbrew/bin/:"
                             (concat home-folder "/.config/yarn/global/node_modules/.bin/:")
                             (concat home-folder "/n/bin/:")
                             (concat home-folder "/.local/bin/:")
                             (concat home-folder "/work/dox-compose/bin/:")
                             (concat home-folder "/.rbenv/shims:")
                             (concat home-folder "/.rbenv/bin:")
                             (concat home-folder "/.fzf/bin:")
                             "/usr/bin:"
                             "/usr/local/bin:"
                             "/usr/local/opt/node@10/bin:"
                             "/bin"))

      (setq exec-path `(
                        "/home/linuxbrew/.linuxbrew/bin/"
                        ,(concat home-folder "/.config/yarn/global/node_modules/.bin/")
                        ,(concat home-folder "/work/dox-compose/bin/")
                        ,(concat home-folder "/n/bin/")
                        ,(concat home-folder "/.rbenv/bin/")
                        ,(concat home-folder "/.rbenv/shims/")
                        ,(concat home-folder "/dotfiles/bin/")
                        ,(concat home-folder "/.fzf/bin")
                        ,(concat home-folder "/.local/bin")
                        "/usr/local/opt/node@10/bin/"
                        "/usr/bin"
                        "/usr/local/bin"
                        "~/bin"
                        "/bin/"
                        "/usr/local/bin/"
                        "/usr/local/sbin/"
                        "/usr/bin/")))
  #+end_src

  Keep emacs fast with large files.
  #+begin_src emacs-lisp
    (defun check-large-file-hook ()
      "If a file is over a given size, turn off minor modes."
      (when (> (buffer-size) (* 1024 100)) ;; 100K
        (fundamental-mode)
        (font-lock-mode -1)
        (setq buffer-read-only t)
        (buffer-disable-undo)))

    (add-hook 'find-file-hooks 'check-large-file-hook)
  #+end_src

  #+begin_src emacs-lisp
    (setq help-window-select t)
    (setq inhibit-startup-message t)
    (setq delete-by-moving-to-trash t)
    (setq tab-always-indent 'complete)
    ;; show end of buffer on left fringe
    (setq-default default-indicate-empty-lines nil)
    (make-variable-buffer-local 'compile-command)
    (defalias 'yes-or-no-p 'y-or-n-p)
    (setq ring-bell-function 'ignore)

    (setq backup-by-copying t      ; don't clobber symlinks
          backup-directory-alist
          '((".*" . "~/.local/share/emacs-saves"))    ; don't litter my fs tree
          delete-old-versions t
          kept-new-versions 6
          kept-old-versions 2
          auto-save-default t ;files starting with # are generated by autosave
          auto-save-timeout 60 ; number of seconds before auto-saving
          auto-save-interval 200 ; number of keystrokes before auto-saves
          version-control t) ; use versioned backups
    (setq create-lockfiles nil)
    (setq auto-save-file-name-transforms
          `((".*" ,"~/.local/share/emacs-saves" t)))

    ;; if file has no change, just load any changes
    ;; coming from an external process
    (setq global-auto-revert-non-file-buffers t)
    (global-auto-revert-mode 1)

    ;; sentences end with one space after point
    (setq sentence-end-double-space nil)

    ;;; replace selected text when typing
    (pending-delete-mode 1)

    (prefer-coding-system 'utf-8)
    (modify-coding-system-alist 'process "\\*compilation\\*\\'"   'utf-8)
  #+end_src

  I want error highlights and error bindings in shell modes too.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'shell-mode-hook 'compilation-shell-minor-mode)
  #+END_SRC

  ~C-c C-w~ to copy regex to something usable with emacs-lisp
  ~C-c C-q~ to quit re-builder and to remove highlights
  #+BEGIN_SRC emacs-lisp
  ( require 're-builder)
  (setq reb-re-syntax 'string)
  #+END_SRC

** tabs and whitespace
   By default I disable tabs. In addition I use ~whitespace-mode~
   because sometimes when copy pasting code from external sources
   those external sources have tabs. I want to see those tabs to
   remove them.

   I don't use the ~global-whitespace-mode~ because some emacs mode
   like ~magit~ use tabs.

   You can remove all tabs from your buffer with ~untabify~
   #+begin_src emacs-lisp
     (setq-default
      indent-tabs-mode nil    ;no tabs
      c-basic-offset 2)
     (setq-default whitespace-style '(face trailing tabs tab-mark))
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
     (add-hook 'prog-mode-hook 'whitespace-mode)
     (eval-after-load "whitespace"
       '(diminish 'whitespace-mode))
   #+end_src

** Recent files
   #+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 50)
(setq recentf-max-saved-items 50)
   #+END_SRC
* GUI
  #+begin_src emacs-lisp
  (blink-cursor-mode 0)
  (column-number-mode)

  (electric-indent-mode t)

  (electric-pair-mode)
  (defun inhibit-electric-pair-mode-in-minibuffer (char)
    (minibufferp))
  (setq electric-pair-inhibit-predicate #'inhibit-electric-pair-mode-in-minibuffer)

  ;; wrap lines when they reach the end of buffer

  ;; file path in frame title
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (abbreviate-file-name (buffer-file-name))
                   "%b"))))


  (define-key my-keys-minor-mode-map (kbd "C-c op") 'show-paren-mode)
  (setq blink-matching-paren 'jump-offscreen)

  ;; makes fringe big enough on linux with HDPI
  (fringe-mode 20)
  #+end_src

  #+BEGIN_SRC emacs-lisp
   (use-package diminish
     :config
     (eval-after-load "undo-tree"
       '(diminish 'undo-tree-mode))
     (diminish 'auto-fill-function)
     (diminish 'my-keys-minor-mode)
     (diminish 'eldoc-mode))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  (use-package posframe)
  #+END_SRC

* Colors
** Pantone

   | Hex     | Pantone Color Name |
   |---------+--------------------|
   | #fff166 | 101U               |
   | #fccf61 | 128u               |
   | #f79b2f | 130u               |
   | #c97f3a | 145u               |
   | #ffa2cb | 210u               |
   | #f56d9e | 213u               |
   | #dcc6ea | 263u               |
   | #bfa1e3 | 264u               |
   | #9d7ad2 | 265u               |
   | #adcff1 | 277u               |
   | #7ab1e8 | 284u               |
   | #5b8edb | 279u               |
   | #8eddeb | 304u               |
   | #00b4e4 | 395u               |
   | #93e8d3 | 331u               |
   | #97d88a | 358u               |
   | #5cb860 | 360u               |
   | #56944f | 362u               |
   | #f1f2f1 | 11-0601 tpx        |
   | #e8eae8 | 11-4800 tpx        |
   | #dad9d6 | cool gray 1u       |
   | #c5c5c5 | cool gray 3u       |
   | #adaeb0 | cool gray 5u       |
   | #939598 | cool gray 8u       |
   | #e4f4e9 | 9063u              |
   | #c5f2e6 | 9520u              |
   | #ffcfd8 | 9284u              |
   | #69615f | 440u               |
   | #4c4e56 | black7u            |
   | #885a61 | 195u               |
   | #f65058 | red 032u           |
   | #bc3e44 | 3517u              |
   | #34855b | 348u               |
   | #546758 | 350u               |
   | #4982cf | 285u               |
   | #3a499c | Reflex Blue U      |
   | #65428a | medium purple      |
** One Half
**** Dark

     | Color Name     | Hex             |
     |----------------+-----------------|
     | "background"   | "#282C34"       |
     | "black"        | "#282C34"       |
     | "blue"         | "#61AFEF"       |
     | "brightBlack"  | "#282C34"       |
     | "brightBlue"   | "#61AFEF"       |
     | "brightCyan"   | "#56B6C2"       |
     | "brightGreen"  | "#98C379"       |
     | "brightPurple" | "#C678DD"       |
     | "brightRed"    | "#E06C75"       |
     | "brightWhite"  | "#DCDFE4"       |
     | "brightYellow" | "#E5C07B"       |
     | "cyan"         | "#56B6C2"       |
     | "foreground"   | "#DCDFE4"       |
     | "green"        | "#98C379"       |
     | "purple"       | "#C678DD"       |
     | "red"          | "#E06C75"       |
     | "white"        | "#DCDFE4"       |
     | "yellow"       | "#E5C07B"       |

**** Light

     | Color Name     | Hex       |
     |----------------+-----------|
     | "background"   | "#FAFAFA" |
     | "black"        | "#383A42" |
     | "blue"         | "#0184BC" |
     | "brightBlack"  | "#383A42" |
     | "brightBlue"   | "#0184BC" |
     | "brightCyan"   | "#0997B3" |
     | "brightGreen"  | "#50A14F" |
     | "brightPurple" | "#A626A4" |
     | "brightRed"    | "#E45649" |
     | "brightWhite"  | "#FAFAFA" |
     | "brightYellow" | "#C18401" |
     | "cyan"         | "#0997B3" |
     | "foreground"   | "#383A42" |
     | "green"        | "#50A14F" |
     | "purple"       | "#A626A4" |
     | "red"          | "#E45649" |
     | "white"        | "#FAFAFA" |
     | "yellow"       | "#C18401" |

** Tronesque
    #081724
    #033340
    #1d5483
    #2872b2
    #d3f9ee
    #a6f3dd
    #effffe
    #fffed9
    #ff694d
    #f5b55f
    #fffe4e
    #afc0fd
    #96a5d9
    #bad6e2
    #d2f1ff
    #68f6cb
* Windows
  #+BEGIN_SRC emacs-lisp
     (define-key my-keys-minor-mode-map (kbd "C-h") 'evil-window-left)
     (define-key my-keys-minor-mode-map (kbd "C-j") 'evil-window-down)
     (define-key my-keys-minor-mode-map (kbd "C-k") 'evil-window-up)
     (define-key my-keys-minor-mode-map (kbd "C-l") 'evil-window-right)

     (define-key my-keys-minor-mode-map (kbd "C-c \\") 'split-window-right)
     (use-package evil
     :config
     (evil-define-key 'normal my-keys-minor-mode-map (kbd "C-c -") 'split-window-below))
  #+END_SRC

* Clojure
  #+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :mode "\\.clj\\'"
  :config
  (add-hook 'clojure-mode-hook #'subword-mode)
  (use-package cider))
  #+END_SRC
* Ruby
  #+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'")

  (use-package ruby-mode
    :mode "\\.rake\\'"
    :mode "Rakefile\\'"
    :mode "\\.gemspec\\'"
    :mode "\\.ru\\'"
    :mode "Gemfile\\'"
    :mode "Guardfile\\'" :mode "Capfile\\'"
    :mode "\\.cap\\'"
    :mode "\\.thor\\'"
    :mode "\\.rabl\\'"
    :mode "Thorfile\\'"
    :mode "Vagrantfile\\'"
    :mode "\\.jbuilder\\'"
    :mode "Podfile\\'"
    :mode "\\.podspec\\'"
    :mode "Puppetfile\\'"
    :mode "Berksfile\\'"
    :mode "Appraisals\\'"
    :mode "\\.rb$"
    :mode "ruby"
    :config

    (add-hook 'ruby-mode-hook 'subword-mode)
    (eval-after-load "subword"
      '(diminish 'subword-mode))
    (use-package ruby-interpolation
      :diminish ruby-interpolation-mode)
    (use-package inf-ruby)

    (use-package ruby-end
      :diminish ruby-end-mode)
    (use-package rspec-mode)

    (use-package ruby-refactor
      :diminish ruby-refactor-mode
      :bind (:map ruby-mode-map
                  ("C-c r m" . ruby-refactor-extract-to-method)
                  ("C-c r c" . ruby-refactor-extract-constant)
                  ("C-c r v" . ruby-refactor-extract-local-variable)
                  ("C-c r l" . ruby-refactor-extract-to-let))
      :config
      (add-hook 'ruby-mode-hook 'ruby-refactor-mode-launch))


    ;; Hitting M-; twice adds an xmpfilter comment. Hitting xmp keybinding will put the output in this comment
    (use-package rcodetools
      :load-path "/site-lisp/rcodetools.el"
      :pin manual
      :ensure nil
      :config
      (defadvice comment-dwim (around rct-hack activate)
        "If comment-dwim is successively called, add => mark."
        (if (and (or (eq major-mode 'enh-ruby-mode)
                     (eq major-mode 'ruby-mode))
                 (eq last-command 'comment-dwim))
            (progn
              (if (eq major-mode 'enh-ruby-mode)
                  (end-of-line))
              (insert "=>"))
          ad-do-it))))
  #+END_SRC
* HTML
  #+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.html\\'")

  (use-package emmet-mode
  :after evil
    :diminish emmet-mode
    :config
    (progn
      (evil-define-key 'insert emmet-mode-keymap (kbd "C-j") 'emmet-expand-line)
      (evil-define-key 'emacs emmet-mode-keymap (kbd "C-j") 'emmet-expand-line))

    (add-hook 'css-mode-hook
              (lambda ()
                (emmet-mode)
                (setq emmet-expand-jsx-className? nil)))

    (add-hook 'sgml-mode-hook
              (lambda ()
                (emmet-mode)
                (setq emmet-expand-jsx-className? nil)))

    (add-hook 'web-mode-hook
              (lambda ()
                (emmet-mode))))
  #+END_SRC
* CSS
  #+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :mode "\\.scss\\'")

(use-package sass-mode :mode "\\.sass\\'")

(use-package less-css-mode
  :mode "\\.less\\'")
  #+END_SRC
* Docker
  #+begin_src emacs-lisp
  (use-package docker
   :ensure t
   :bind ("C-c d d". docker)
   :config
      (defadvice docker-image-mode (after docker-image-mode-change-to-emacs-state activate compile)
        "when entering git-timemachine mode, change evil normal state to emacs state"
        (if (evil-normal-state-p)
            (evil-emacs-state)
          (evil-normal-state)))
          )

  ;; (use-package transient)
  ;; (require 'dox-dc)
  ;; (define-key my-keys-minor-mode-map (kbd "C-c d x") (dox-dc))
  ;; (evil-set-initial-state 'dox-dc-mode 'emacs)
  #+end_src
* JavaScript
  #+BEGIN_SRC emacs-lisp
  (require 'compile)
  (setq compilation-error-regexp-alist-alist
        (cons '(node "^\\([a-zA-Z\.0-9\/-]+\\):\\([0-9]+\\)$"
                     1 ;; file
                     2 ;; line
                     )
              compilation-error-regexp-alist-alist))
  (setq compilation-error-regexp-alist
        (cons 'node compilation-error-regexp-alist))
  (add-hook 'js2-mode-hook
            (lambda ()
              (set (make-local-variable 'compile-command)
                   (format "node %s" (file-name-nondirectory buffer-file-name)))))

  (setq js-indent-level 2)

  (use-package js2-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (add-to-list 'auto-mode-alist '("\\.jsx\\'" . js2-mode))
    (setq js2-mode-show-parse-errors nil)
    (setq js2-mode-show-strict-warnings nil)

    (setq-default
     ;; js2-mode
     js2-basic-offset 2
     ;; web-mode
     css-indent-offset 2
     web-mode-markup-indent-offset 2
     web-mode-script-padding 0
     web-mode-css-indent-offset 2
     web-mode-style-padding 2
     web-mode-code-indent-offset 2
     web-mode-attr-indent-offset 2)

    (setq js2-highlight-level 3)
    :config
    (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
    (add-hook 'js2-mode-hook (lambda() (subword-mode t)))

    (use-package import-js)

    (use-package xref-js2)

    ;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
    ;; unbind it.
    (define-key js-mode-map (kbd "M-.") nil)

    (add-hook 'js2-mode-hook (lambda ()
                               (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
    (use-package prettier-js
      :diminish prettier-js-mode
      :config
      (setq prettier-args '(
                            "--trailing-comma" "es5"
                            "--single-quote" "true"
                            )
            prettier-js-command "prettier")
      (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
      (add-hook 'js2-mode-hook 'prettier-js-mode))

  (defun enable-minor-mode (my-pair)
    "Enable minor mode if filename match the regexp.  MY-PAIR is a cons cell (regexp . minor-mode)."
    (if (buffer-file-name)
        (if (string-match (car my-pair) buffer-file-name)
            (funcall (cdr my-pair)))))

  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.jsx?\\'" . prettier-js-mode))))

  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.vue?\\'" . prettier-js-mode))))

  (add-to-list 'magic-mode-alist '("^import.*React.* from 'react'" . my-jsx-hook) )
  (defun my-jsx-hook ()
    "My Hook for JSX Files"
    (interactive)
    (web-mode)
    (web-mode-set-content-type "jsx")
    (setq imenu-create-index-function 'auray-js-imenu-make-index)
    (flycheck-select-checker 'javascript-eslint)
    (emmet-mode)
    (setq emmet-expand-jsx-className? t)
    (tern-mode t))
    )

  (use-package context-coloring
    :ensure t
    :diminish context-coloring-mode
    :bind (:map my-keys-minor-mode-map ("C-c oc" . context-coloring-mode))
    :config
      (add-hook 'js2-mode-hook #'context-coloring-mode))

  (use-package json-mode
    :mode "\\.json\\'"
    :mode "\\.eslintrc\\'")

  (use-package coffee-mode
    :mode "\\.coffee\\'"
    :config
    (use-package highlight-indentation)
    (add-hook 'coffee-mode-hook '(lambda () (highlight-indentation-mode)))
    (add-hook 'coffee-mode-hook '(lambda () (subword-mode +1)))
    (custom-set-variables '(coffee-tab-width 2)))

  (use-package typescript-mode
    :mode "\\.ts\\'")
  #+END_SRC
** Vue
   #+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.vue\\'"
    :config
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-script-padding 0)
    (defun jjpandari/merge-imenu (index-fun)
      (interactive)
      (let ((mode-imenu (funcall index-fun))
            (custom-imenu (imenu--generic-function imenu-generic-expression)))
        (append custom-imenu mode-imenu)))

    (add-hook 'web-mode-hook
              (lambda ()
                (setq imenu-create-index-function (lambda () (jjpandari/merge-imenu 'web-mode-imenu-index))))))

   #+END_SRC
* Flycheck
  #+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish flycheck-mode
    :config
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    (add-hook 'web-mode-hook 'flycheck-mode)
    (add-hook 'js2-mode-hook 'flycheck-mode)
    (defun my/use-eslint-from-node-modules ()
      (let* ((root (locate-dominating-file
                    (or (buffer-file-name) default-directory)
                    "node_modules"))
             (eslint (and root
                          (expand-file-name "node_modules/eslint/bin/eslint.js"
                                            root))))
        (when (and eslint (file-executable-p eslint))
          (setq-local flycheck-javascript-eslint-executable eslint))))
    (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)


  (define-derived-mode cfn-mode yaml-mode
    "Cloudformation"
    "Cloudformation template mode.")
  (add-to-list 'auto-mode-alist '(".template.yaml\\'" . cfn-mode))
  (add-hook 'cfn-mode-hook 'flycheck-mode)
  (flycheck-define-checker cfn-lint
    "A Cloudformation linter using cfn-python-lint.
              See URL 'https://github.com/awslabs/cfn-python-lint'."
    :command ("cfn-lint" "-f" "parseable" source)
    :error-patterns (
                     (warning line-start (file-name) ":" line ":" column
                              ":" (one-or-more digit) ":" (one-or-more digit) ":"
                              (id "W" (one-or-more digit)) ":" (message) line-end)
                     (error line-start (file-name) ":" line ":" column
                            ":" (one-or-more digit) ":" (one-or-more digit) ":"
                            (id "E" (one-or-more digit)) ":" (message) line-end)
                     )
    :modes (cfn-mode))
  (add-to-list 'flycheck-checkers 'cfn-lint))

  (require 'aurayb-narrow-indirect-vue)
  ;; (define-key my-keys-minor-mode-map (kbd "nj") (aurayb-make-narrow-indirect-vue "script" 'js2-mode))
  ;; (define-key my-keys-minor-mode-map (kbd "nh") (aurayb-make-narrow-indirect-vue "template" 'html-mode))
  ;; (define-key my-keys-minor-mode-map (kbd "ns") (aurayb-make-narrow-indirect-vue "style" 'scss-mode))
  ;; (define-key my-keys-minor-mode-map (kbd "nn") '(lambda () (interactive) (pop-to-buffer-same-window (buffer-base-buffer))))
  #+END_SRC
* Run for mode
  #+BEGIN_SRC emacs-lisp
(defun run-for-mode ()
    "Run interactive command for the current buffer programming mode"
    (interactive)
    (cond
     ((equal major-mode 'org-mode)
      (org-babel-execute-src-block))
     ((equal major-mode 'ruby-mode)
      (xmp))
     ((equal major-mode 'enh-ruby-mode)
      (xmp))
     ((equal major-mode 'clojure-mode)
      (cider-eval-defun-at-point))
     ((equal major-mode 'clojurescript-mode)
      (cider-eval-defun-at-point))
     ((or (equal major-mode 'emacs-lisp-mode) (equal major-mode 'lisp-interaction-mode))
      (eval-defun nil))
     ((equal major-mode 'js2-mode)
      (run-node-on-buffer))
     (t (error "No run command for that mode"))))


(defun run-bigger-for-mode ()
    "Run interactive command for the current buffer programming mode"
    (interactive)
    (cond
     ((equal major-mode 'org-mode)
      (org-publish-current-file))
     ((equal major-mode 'ruby-mode)
      (xmp))
     ((equal major-mode 'enh-ruby-mode)
      (xmp))
     ((equal major-mode 'clojure-mode)
      (cider-load-buffer))
     ((equal major-mode 'clojurescript-mode)
      (cider-load-buffer))
     ((or (equal major-mode 'emacs-lisp-mode) (equal major-mode 'lisp-interaction-mode))
      (eval-defun nil))
     ((equal major-mode 'js2-mode)
      (progn
        (js-comint-reset-repl)
        (js-comint-send-buffer)
        (other-window -1)))
     (t (error "No run command for that mode"))))

(define-key my-keys-minor-mode-map (kbd "C-c x") 'run-for-mode)
(define-key my-keys-minor-mode-map (kbd "C-c X") 'run-bigger-for-mode)
  #+END_SRC
* Bindings
** General
   Easier to type M-x
   #+begin_src emacs-lisp
   (define-key my-keys-minor-mode-map (kbd "C-x C-m") 'execute-extended-command)
   (define-key my-keys-minor-mode-map (kbd "C-c C-m") 'execute-extended-command)
   #+end_src

   Shows key combination helper in minibuffer
   #+begin_src emacs-lisp
     (use-package which-key
       :diminish which-key-mode
       :config
       (which-key-mode))
   #+end_src

   Combined with C-M-c (exit-recursive-edit) allows to stop doing
   something, do something else and come back to it later.
   #+begin_src emacs-lisp
    (define-key my-keys-minor-mode-map (kbd "C-M-e") 'recursive-edit)
   #+end_src

   Make grep buffers writable with ~C-c C-p~. Apply changes with ~C-c C-e~
   #+begin_src emacs-lisp
    ;; makes grep buffers writable and apply the changes to files.
    (use-package wgrep :defer t)
   #+end_src

   #+begin_src emacs-lisp
   (use-package paredit
     :diminish paredit-mode
     :bind (:map my-keys-minor-mode-map
            ("C-)" . paredit-forward-slurp-sexp)
            ("C-}" . paredit-forward-bard-sexp))
     :config
     (add-hook 'emacs-lisp-mode-hook #'paredit-mode))

   (use-package expand-region
     :bind (:map my-keys-minor-mode-map ("C-c w" . er/expand-region)))

   (define-key my-keys-minor-mode-map (kbd "C-c a") 'org-agenda)
   (define-key my-keys-minor-mode-map (kbd "C-c R") 'revert-buffer)
   (define-key my-keys-minor-mode-map (kbd "C-c jc") 'org-clock-jump-to-current-clock)
   (define-key my-keys-minor-mode-map (kbd "C-c je") '(lambda () (interactive) (find-file "~/dotfiles/emacs/.emacs.d/Aurelien.org")))
   (define-key my-keys-minor-mode-map (kbd "C-c jp") '(lambda () (interactive) (find-file "~/projects/")))
   (define-key my-keys-minor-mode-map (kbd "C-c jw") '(lambda () (interactive) (find-file **local-writing-folder**)))
   (define-key my-keys-minor-mode-map (kbd "C-c jn") '(lambda () (interactive) (find-file **local-note-file**)))
   (define-key my-keys-minor-mode-map (kbd "C-c jj") 'dired-jump)
   (define-key my-keys-minor-mode-map (kbd "C-c k") 'recompile)
   (define-key my-keys-minor-mode-map (kbd "C-c K") 'compile)

   (define-key my-keys-minor-mode-map (kbd "<f5>") 'ispell-buffer)
   ;;(use-package define-word
   ;;  :config
   ;;  (define-key my-keys-minor-mode-map (kbd "<f6>") 'define-word-at-point))

   ;; (defun lookup-synonyms (word)
   ;;   (interactive (list (save-excursion (car (ispell-get-word nil)))))
   ;;   (browse-url (format "http://en.wiktionary.org/wiki/%s" word)))

   ;; (define-key my-keys-minor-mode-map (kbd "<f7>") 'lookup-synonyms)

   (define-key my-keys-minor-mode-map (kbd "C-c h") 'highlight-symbol-at-point)
   (define-key my-keys-minor-mode-map (kbd "C-c H") 'unhighlight-regexp)
   (define-key my-keys-minor-mode-map (kbd "C-c oh") '(lambda ()
     (interactive)
     (hi-lock-mode -1)
     (evil-search-highlight-persist-remove-all)))
   (defun hide-line-numbers ()
     (interactive)
     (setq display-line-numbers (quote nil)))
   (define-key my-keys-minor-mode-map (kbd "C-c olh") 'hide-line-numbers)
   (defun show-line-numbers ()
     (interactive)
     (setq display-line-numbers (quote absolute)))
   (define-key my-keys-minor-mode-map (kbd "C-c oll") 'show-line-numbers)
   (define-key my-keys-minor-mode-map (kbd "C-c ow") 'visual-line-mode)
   (define-key my-keys-minor-mode-map (kbd "C-c of") 'auto-fill-mode)
   (define-key my-keys-minor-mode-map (kbd "C-c og") 'global-hl-line-mode)
   (use-package rainbow-mode
     :diminish rainbow-mode
     :bind (:map my-keys-minor-mode-map
                 ("C-c or" . rainbow-mode)))
   ;; gives each line only one visual line and don't show a continuation on next line
   (set-default 'truncate-lines t)
   (define-key my-keys-minor-mode-map (kbd "C-c ot") 'toggle-truncate-lines)

   (define-key evil-normal-state-map (kbd "[b") 'previous-buffer)
   (define-key evil-normal-state-map (kbd "]b") 'next-buffer)
   (define-key evil-normal-state-map (kbd "]e") 'next-error)
   (define-key evil-normal-state-map (kbd "[e") 'previous-error)

   (use-package windresize
     :bind (:map evil-normal-state-map
                 ("C-w r" . windresize)))
   #+end_src
** Drag stuff
   #+begin_src emacs-lisp
     (use-package drag-stuff
       :diminish t
       :bind (:map my-keys-minor-mode-map
              ("C-M-<up>" . drag-stuff-up)
              ("C-M-<down>" . drag-stuff-down))
       :config
       (drag-stuff-global-mode t))
   #+end_src
   #+begin_src emacs-lisp
  (use-package key-chord
    :after evil
    :config
    (key-chord-mode 1)
    (key-chord-define evil-insert-state-map  "jk" 'evil-normal-state))
   #+end_src

   #+begin_src emacs-lisp
    (use-package evil
      :config
      (evil-define-key 'insert lisp-interaction-mode-map (kbd "C-j") 'eval-print-last-sexp))
   #+end_src
* Tmux Integration and Buffer navigation
  Move between buffers with C-h C-j C-k C-l and makes Emacs terminal
  and tmux work seamlessly.
  #+begin_src emacs-lisp
       ;; (use-package emamux
       ;;   :bind (:map my-keys-minor-mode-map
       ;;               ("C-c c c" . emamux:send-command)
       ;;               ("C-c c l" . emamux:run-last-command)))

       (defun tmux-socket-command-string ()
         (interactive)
         (concat "tmux -S "
                 (replace-regexp-in-string "\n\\'" ""
                                           (shell-command-to-string "echo $TMUX | sed -e 's/,.*//g'"))))

       (defun tmux-move-right ()
         (interactive)
         (condition-case nil
             (evil-window-right 1)
           (error (unless window-system (shell-command (concat
   (tmux-socket-command-string) " select-pane -R") nil)))))

       (defun tmux-move-left ()
         (interactive)
         (condition-case nil
             (evil-window-left 1)
           (error (unless window-system (shell-command (concat
   (tmux-socket-command-string) " select-pane -L") nil)))))

       (defun tmux-move-up ()
         (interactive)
         (condition-case nil
             (evil-window-up 1)
           (error (unless window-system (shell-command (concat
   (tmux-socket-command-string) " select-pane -U") nil)))))

       (defun tmux-move-down ()
         (interactive)
         (condition-case nil
             (evil-window-down 1)
           (error (unless window-system (shell-command (concat
   (tmux-socket-command-string) " select-pane -D") nil)))))

       (define-key my-keys-minor-mode-map (kbd "C-h") 'tmux-move-left)
       (define-key my-keys-minor-mode-map (kbd "C-j") 'tmux-move-down)
       (define-key my-keys-minor-mode-map (kbd "C-k") 'tmux-move-up)
       (define-key my-keys-minor-mode-map (kbd "C-l") 'tmux-move-right)
  #+end_src

* Completion

  #+BEGIN_SRC emacs-lisp :results value
   (use-package company
     :commands (company-mode global-company-mode company-complete
                             company-complete-common company-manual-begin company-grab-line)
     :after evil
     :config
     (setq company-idle-delay nil
           company-tooltip-limit 10
           company-dabbrev-downcase nil
           company-dabbrev-ignore-case nil
           company-dabbrev-code-other-buffers t
           company-tooltip-align-annotations t
           company-require-match 'never
           company-global-modes '(not eshell-mode comint-mode erc-mode message-mode help-mode gud-mode)
           company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)
           company-backends '(company-capf company-dabbrev company-ispell company-yasnippet)
           company-transformers '(company-sort-by-occurrence))
     (global-company-mode +1))

     (define-key evil-insert-state-map (kbd "C-c c") 'company-complete)
   ;; helps rank completion candidates based on usage
   (use-package company-statistics
     :after company
     :config
     (setq company-statistics-file "~/.emacs.d/company-stats-cache.el")
     (company-statistics-mode +1))

   (use-package company-dict
     :commands company-dict
     :config
     (defun +company|enable-project-dicts (mode &rest _)
       "Enable per-project dictionaries."
       (if (symbol-value mode)
           (cl-pushnew mode company-dict-minor-mode-list :test #'eq)
         (setq company-dict-minor-mode-list (delq mode company-dict-minor-mode-list))))
     (add-hook 'projectile-after-switch-project-hook #'+company|enable-project-dicts))


     (autoload 'company-capf "company-capf")
     (autoload 'company-yasnippet "company-yasnippet")
     (autoload 'company-dabbrev "company-dabbrev")
     (autoload 'company-dabbrev-code "company-dabbrev-code")
     (autoload 'company-etags "company-etags")
     (autoload 'company-elisp "company-elisp")
     (autoload 'company-files "company-files")
     (autoload 'company-gtags "company-gtags")
     (autoload 'company-ispell "company-ispell")
  #+END_SRC
* Notes
  Some people switch to Emacs just to use org-mode.

  It is one of the best tool for note taking and writing

  Setting the org-directory helps integration with org-agenda and
  for org template captures.
  #+begin_src emacs-lisp
  (setq org-directory **local-org-folder**)
  #+end_src

  #+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'turn-on-auto-fill)

  (add-hook 'org-capture-mode-hook 'evil-insert-state)

  (use-package evil
    :init
    (setq org-use-speed-commands nil)
    :config
    (evil-define-key 'normal org-mode-map
      (kbd "M-l") 'org-shiftmetaright
      (kbd "M-h") 'org-shiftmetaleft
      (kbd "M-k") 'org-move-subtree-up
      (kbd "M-j") 'org-move-subtree-down
      (kbd "M-p") 'org-publish-current-project
      (kbd "TAB") 'org-cycle)
    )
  (add-to-list 'org-modules "org-habit")
  (setq org-log-into-drawer t)

  (setq org-todo-keywords
        '((sequence "TODO" "WAITING" "|" "DONE(!)")))
  #+end_src

** Capture Ideas

   This is a most important binding.
   ~C-c l~ to store a link and ~C-c C-l~ to insert that link.

   If you have a selection, it will be part of the link and Emacs will
   actually look for that selection If you visit the link.
   #+begin_src emacs-lisp
   (define-key my-keys-minor-mode-map "\C-cl" 'org-store-link)
   #+end_src

   Palimpsest makes it easier to quickly discard blocks of text.
   Main use is to just send the block of text at the bottom of the
   buffer. This way I can revise my writing without losing my drafts.
   ~C-c C-q~ move region to trash
   ~C-c C-r~ move region to bottom
   #+begin_src emacs-lisp
   (use-package palimpsest
     :diminish palimpsest-mode
     :config
     (add-hook 'org-mode-hook 'palimpsest-mode))
   #+end_src

   #+begin_src emacs-lisp
    (setq org-capture-templates
           '(("n" "Notes" entry (file+headline **local-note-file** "Inbox") "* %?\n")))

    (define-key my-keys-minor-mode-map (kbd "C-c n") 'org-capture)
    (add-hook 'org-capture-mode-hook 'evil-insert-state)
   #+end_src

   To launch an Emacs client with a capture frame selecting the ~n~ template
   ~emacsclient -ca "" --frame-parameters='(quote (name .
   "global-org-capture"))' -e '(org-capture nil "n")'~.

   It works nicely on Linux, however on Mac the focus and input focus
   is sketchy and is not reliable.

   The following takes advantage that I name those capture frame
   ~global-org-capture~ to do some housekeeping around them
   #+begin_src emacs-lisp
     (defadvice org-capture-finalize
         (after delete-capture-frame activate)
       "Advise capture-finalize to close the frame"
       (if (equal "global-org-capture" (frame-parameter nil 'name))
           (progn
             (delete-frame))))

     (defadvice org-capture-destroy
         (after delete-capture-frame activate)
       "Advise capture-destroy to close the frame"
       (if (equal "global-org-capture" (frame-parameter nil 'name))
           (progn
             (delete-frame))))

     ;; make the frame contain a single window. by default org-capture
     ;; splits the window.
     (add-hook 'org-capture-mode-hook
               'delete-other-windows)
   #+end_src

** Inline Code

   Org babel allows to evaluate code snippets inside org files.
   This is the best way I know of doing [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]]

   This loads more programming languages to use with org-babel.
   #+begin_src emacs-lisp
   (require 'ob-clojure) ;; run cider-jack-in from org buffer to be able to run
                         ;; clojure code
   (use-package ob-clojurescript) ;; requires [[https://github.com/anmonteiro/lumo][lumo]]
   (setq org-babel-clojure-backend 'cider)
   (require 'ob-js)
   (org-babel-do-load-languages 'org-babel-load-languages
                                '((shell . t)
                                  (ditaa . t)))
   (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.11.0/libexec/ditaa-0.11.0-standalone.jar")
   #+end_src

** Publish
   My strategy is to keep my writings in the same folder
   ~$HOME/Dropbox/org/writing~ and run ~org-publish-current-file~ or
   ~org-publish~ to export to HTML.

   The HTML export has just the body. I then use a tool like ~jekyll~
   or ~hugo~ to make it accessible on internet.
   #+begin_src emacs-lisp
     (setq
      time-stamp-active t
      time-stamp-line-limit 30     ; check first 30 buffer lines for Time-stamp:
      time-stamp-format "%04y-%02m-%02d") ;

     (setq system-time-locale "C") ;; make sure time local is in english when exporting
     (setq org-html-validation-link nil)
     (setq org-publish-project-alist
           '(
             ("wiki-files"
              :base-directory **local-writing-folder**
              :base-extension "org"
              :publishing-directory **local-published-folder**
              :recursive t
              :publishing-function org-html-publish-to-html
              :headline-levels 4             ; Just the default for this project.
              :auto-preamble t
              :html-head nil
              :html-head-extra nil
              :body-only true
              )
             ;; ... add all the components here (see below)...
             ;; ("wiki" :components ("wiki-files"))
             )
           org-export-with-toc nil
           org-html-doctype "html5"
           org-html-head nil
           org-html-head-include-default-style nil
           org-html-head-include-scripts nil
           org-html-html5-fancy t
           org-html-postamble nil
           org-html-indent t)

     (add-hook 'org-mode-hook
               (lambda ()
                 (setq-local time-stamp-start "Updated on[ 	]+\\\\?[\"<]+")
                 (add-hook 'before-save-hook 'time-stamp nil 'local)))

     (add-hook 'write-file-hooks 'time-stamp) ; update when saving
     (require 'ox-publish)
     (setq system-time-locale "C") ;; make sure time local is in english when exporting
     (setq org-html-validation-link nil)
   #+end_src

** Feedback

   Ispell buffer with ~s-:r~
   Ispell word with ~z =~
   #+begin_src emacs-lisp
   (setq ispell-program-name "aspell")
   (setq ispell-personal-dictionary **local-personal-dictionary**)
   ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
   (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))

   (add-hook 'org-mode-hook 'turn-on-flyspell)
   (eval-after-load "flyspell"
        '(diminish 'flyspell-mode))
   #+end_src

   Word definition
   #+begin_src emacs-lisp
   (use-package define-word
     :config
     (evil-define-key 'normal org-mode-map
       (kbd "z w") 'define-word-at-point))
   #+end_src

   Word synonyms.
   #+begin_src emacs-lisp
   (use-package powerthesaurus
     :config
     (evil-define-key 'normal org-mode-map
       (kbd "z s") 'powerthesaurus-lookup-word-dwim))
   #+end_src

   For most documents, aim for a score of approximately 60 to 70 for
   the reading ease and 7.0 to 8.0 for the grade level.
   #+begin_src emacs-lisp
   (use-package writegood-mode
    :config
    (evil-define-key 'normal org-mode-map
       (kbd "z g g") 'writegood-mode)
    (evil-define-key 'normal org-mode-map
       (kbd "z g r") 'writegood-reading-ease)
    (evil-define-key 'normal org-mode-map
       (kbd "z g l") 'writegood-grade-level))
   #+end_src

   If you need additional feedback from an external service here is an
   easy way to do it:
   #+begin_src emacs-lisp
   (require 'browse-url) ; part of gnu emacs

   (defun my-lookup-wikipedia ()
     "Look up the word under cursor in Wikipedia.
   If there is a text selection (a phrase), use that.

   This command switches to browser."
     (interactive)
     (let (word)
       (setq word
             (if (use-region-p)
                 (buffer-substring-no-properties (region-beginning) (region-end))
               (current-word)))
       (setq word (replace-regexp-in-string " " "_" word))
       (browse-url (concat "http://en.wikipedia.org/wiki/" word))
       ;; (eww myUrl) ; emacs's own browser
       ))
   #+end_src

* Vim
  I started using Vim to help me prevent [[https://www.emacswiki.org/emacs/RepeatedStrainInjury][emacs RSI.]]
  Now I am sticking with it because It makes me feel like beethoven
  manipulating text :-)

  Here is an awesome [[https://github.com/noctuid/evil-guide][Evil Guide]]

  Quit read-only windows with Q instead of trying to register a Vim
  Macro.
  This is mainly to restore emacs behavior with help windows.
  #+begin_src emacs-lisp
  (use-package evil
    :config
    (defun my-evil-record-macro ()
      (interactive)
      (if buffer-read-only
          (quit-window)
        (call-interactively 'evil-record-macro)))

    (with-eval-after-load 'evil-maps
      (define-key evil-normal-state-map (kbd "q") 'my-evil-record-macro)))
  #+end_src

  Surround things with
  - ~S~ in visual mode
  - ~ys<text-object>~ in normal mode
  You can also change surroundings ~cs~ or delete surroundings ~ds~.
  #+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :config
    (global-evil-surround-mode 1))
  #+end_src

  Comment things with ~gc~. Comment and copy with ~gy~
  #+begin_src emacs-lisp
  (use-package evil-commentary
    :after evil
    :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
  #+end_src

  Start a search from visual selection with ~*~ or ~#~ (backward).
  #+begin_src emacs-lisp
  (use-package evil-visualstar
    :after evil
    :config
    (global-evil-visualstar-mode t))
  #+end_src

  Jump to matching pairs with ~%~.
  #+begin_src emacs-lisp
  (use-package evil-matchit
    :after evil
    :config
    (global-evil-matchit-mode 1))
  #+end_src

  Persist highlight from ~evil search~ and ~isearch~
  #+begin_src emacs-lisp
  (use-package evil-search-highlight-persist
    :config
    (global-evil-search-highlight-persist t))
  #+end_src

  #+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    (setq evil-mode-line-format nil)
    :config

    (evil-mode 1)
    (evil-set-initial-state 'deft-mode 'insert)
    (evil-set-initial-state 'dired-mode 'emacs)
    (evil-set-initial-state 'magit-mode 'emacs)
    (evil-set-initial-state 'magit-mode 'emacs)
    (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)

    (evil-ex-define-cmd "W" 'save-buffer))
  #+end_src

  Changes modeline color depending on Evil state, if buffer is
  modified etc...
  #+begin_src emacs-lisp
     (lexical-let ((default-color (cons (face-background 'mode-line)
                                      (face-foreground 'mode-line))))
     (add-hook 'post-command-hook
               (lambda ()
                 (let ((color (cond ((minibufferp) default-color)
                                    ((evil-emacs-state-p)  '("#ffa2cb" . "#4c4e56"))
                                    ((evil-visual-state-p) '("#adcff1" . "#4c4e56"))
                                    ((evil-insert-state-p)  '("#97d88a" . "#4c4e56"))
                                    ((buffer-modified-p)   '("#f79b2f" . "#4c4e56"))
                                    (t default-color)))
                       )

                   (set-face-attribute 'mode-line nil :box `(:line-width 2 :color ,(car color)))
                   (set-face-background 'mode-line (car color))
                   (set-face-foreground 'mode-line-buffer-id (cdr color))
                   (set-face-foreground 'mode-line (cdr color))))))

  #+end_src

  Make my cursor match my modeline color
  #+begin_src emacs-lisp
(use-package evil
  :config
    (setq evil-insert-state-cursor '(bar "#97d88a")
          evil-visual-state-cursor '(box "#adcff1")
          evil-emacs-state-cursor '(box "#ffa2cb")
          evil-normal-state-cursor '(box "#bc3e44")))
  #+end_src

  Add text objects to select, copy things based on indentation level.
  Use it with ~vii~ and ~yii~.
  #+begin_src emacs-lisp
(use-package evil-indent-plus
  :after evil
  :config
  (evil-indent-plus-default-bindings))
  #+end_src

* Search
  Searching is probably the most important thing in a code editor.
  Here is how I search.

** Search in current file/buffer

   I have two main way to search in a buffer:

*** Vim way
    I use ~evil-search-forward~ (bound to ~/~) and
    ~evil-search-backward~ (bound to ~?~) as it allows me to do
    powerful /vim/ combinations.

    For example I do a search, then navigate through the search list
    with ~n~ or ~N~. Or do a search then replace matches with ~:
    %s//replacement/gc~

*** swiper
    I use ~swiper-isearch~ when I am exploring the buffer or when I
    want to do some search refinements or complex replacements.

    From counsel it is easy to swith to occur with ~C-c C-o~. This
    allows me to have a list of matches in a seperate buffer and edit
    them using:
    - ~C-x C-q~
    - make the changes in the occur buffer
    - ~C-x C-s~ to save the changes

    #+begin_src emacs-lisp
      (use-package ivy
        :diminish ivy-mode
        :bind (("C-s" . swiper-isearch)
               :map my-keys-minor-mode-map
               ("C-c v" . ivy-push-view)
               ("C-c V" . ivy-pop-view))
        :init
        (setq ivy-use-selectable-prompt t)
        ;; enable bookmarks and recent-f
        (setq ivy-use-virtual-buffers t)
        (setq enable-recursive-minibuffers t)
        (setq ivy-initial-inputs-alist nil)
        (setq ivy-re-builders-alist
              '((t . ivy--regex-plus)))
        :config
        (use-package ivy-hydra)
        (ivy-mode 1)
        (defun ivy-switch-buffer-occur ()
          "Occur function for `ivy-switch-buffer' using `ibuffer'."
          (ibuffer nil (buffer-name) (list (cons 'name ivy--old-re))))
        (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))
        (eval-after-load "ivy"
          '(define-key ivy-minibuffer-map (kbd "C-c SPC") 'ivy-restrict-to-matches))
    #+end_src

** Search in visible windows
   #+BEGIN_SRC emacs-lisp
      (use-package avy
        :bind (:map my-keys-minor-mode-map
               ("C-;" . avy-goto-char-timer)))
   #+END_SRC
** Search in project

   ~counsel-rg~ is my main way to search. Invoked with an argument, it
   allows you to specify the directory and search options.
   #+begin_src emacs-lisp
    (use-package counsel
      :bind (:map my-keys-minor-mode-map ("C-c f" . counsel-rg)))
   #+end_src

   When I am investigating things, I like to see a preview of the
   results as I scroll down the search results. I do it with ~C-o~ then
   either ~g~ on the entry I want to preview or ~c~ to automatically
   preview results as I move through the result list.

   A trick I am learning is to use ~C-'~ to jump directly to a
   search results.

*** When I need to narrow down my search to specific files

**** Narrowing on the file-type

     Launch ~counsel-rg~ with a prefix and then I can use for example
     ~-tjs~ as an argument to search only inside javascript files.
     ~-Tjs~ searches inside files but javascript ones.

**** From Dired
     ~C-x d~ to launch dired . I mark the files I am interested in with
     ~m~. Then I can grep those files with ~A~ and do a query replace
     with ~Q~.
** Search Emacs documentation

   Remplacements for emacs search and completion commands.
   I find the UI better.
   #+begin_src emacs-lisp
     (use-package counsel
       :bind (("M-x" . counsel-M-x)
              ("C-x C-f" . counsel-find-file)
              ("<f1> f" . counsel-describe-function)
              ("<f1> v" . counsel-describe-variable)
              ("<f1> l" . counsel-find-library)
              ("<f2> i" . counsel-info-lookup-symbol)
              ("<f2> u" . counsel-unicode-char)
              :map minibuffer-local-map
              ("C-r" . counsel-minibuffer-history)
              :map my-keys-minor-mode-map
              ("C-c r" . counsel-recentf)
              ("C-c i" . counsel-imenu)
              ("C-c b" . counsel-ibuffer)
              ("C-c m" . counsel-bookmark))
       :init
       (setq counsel-git-cmd "rg --files")
       (setq counsel-rg-base-command
             "rg --smart-case -M 120 --hidden --no-heading --line-number --color never %s ."))

     (eval-after-load "counsel" '(progn
                                   (defun counsel-imenu-categorize-functions (items)
                                     "Categorize all the functions of imenu."
                                     (let ((fns (cl-remove-if #'listp items :key #'cdr)))
                                       (if fns
                                           (nconc (cl-remove-if #'nlistp items :key #'cdr)
                                                  `((":" ,@fns)))
                                         items)))))

   #+end_src

** Rename

   Prefix with ~0~ to only match in current function.
   Prefix with universal argument to repeat the previous iedit match.
   Select region and press ~F6~ again to restrict to region.
   ~tab~ and ~S-tab~ to navigate between matches. ~M-;~ to clear a match.

   Shows only matching lines with ~C-'~
   #+begin_src emacs-lisp
     (use-package iedit
      :bind (:map my-keys-minor-mode-map ("<f6>" . iedit-mode)))
   #+end_src

   Sometimes I like to use the mouse to setup multiple cursors. For
   other /multiple-cursors/ usage I prefer to use either
   ~evil-visual-block-mode~ or ~iedit~.
   #+begin_src emacs-lisp
   (use-package multiple-cursors
   :bind (:map my-keys-minor-mode-map ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
   #+end_src

* VCS
  I mainly use git. I prefix all git related keybindings with ~c-c g~.

  Don't forget emacs vcs features accessible with the prefix ~C-x v~!

** Resolving conflicts

   This is to prevent popup windows when resolving file conflicts.
   I prefer to have the ediff take over and restove the windows when
   done.

   #+begin_src emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
     (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
     (setq ediff-split-window-function 'split-window-vertically)
   #+end_src

** Working with github

   To grab a link I can share with co-workers from the region or file.
   #+begin_src emacs-lisp
     (use-package git-link
       :bind (:map my-keys-minor-mode-map
                   ("C-c gl" . git-link)))
   #+end_src

   Otherwise I launch a ~gitsh~ session and I use [[https://github.com/github/hub][hub]] to interact with
   github directly

** View History
*** timemachine
    Allows to view previous versions of a file. It is not focused on the
    diff but on the file itself. Use ~n~ and ~p~ to navigate between
    versions.
    #+begin_src emacs-lisp
     (use-package git-timemachine
       :bind (:map my-keys-minor-mode-map
                   ("C-c gt" . git-timemachine-toggle))
       :config
       (defadvice git-timemachine-mode (after git-timemachine-change-to-emacs-state activate compile)
         "when entering git-timemachine mode, change evil normal state to emacs state"
         (if (evil-normal-state-p)
             (evil-emacs-state)
           (evil-normal-state)))

       (ad-activate 'git-timemachine-mode))
    #+end_src
*** vc-annotate

    Bound to ~C-x v g~.
    - Use ~l~ to see the commit message
    - ~f~ to see what the file looked like at that revision. You can
      then use /git-link/ to grab a link with ~C-c gl~
    - ~n~ and ~p~ to navigate between revisions
    - ~=~ to see the diff.


    I prefer to use a full-window with vc-annotate
    #+begin_src emacs-lisp
     (use-package fullframe
       :config
       (fullframe vc-annotate quit-window))
    #+end_src

    also q to quit window everywhere?
    #+begin_src emacs-lisp
     (eval-after-load "vc-annotate"
          '(progn
           (define-key vc-annotate-mode-map "j" 'evil-next-line)
           (define-key vc-annotate-mode-map "k" 'evil-previous-line)))

     (use-package evil
       :config
       (evil-define-key 'normal diff-mode-map (kbd "q") 'quit-window))
    #+end_src

** Magit

   #+BEGIN_QUOTE
   [[https://magit.vc/][Magit]] is an interface to the version control system Git, implemented
   as an Emacs package. Magit aspires to be a complete Git porcelain.
   While we cannot (yet) claim that Magit wraps and improves upon each
   and every Git command, it is complete enough to allow even
   experienced Git users to perform almost all of their daily version
   control tasks directly from within Emacs. While many fine Git
   clients exist, only Magit and Git itself deserve to be called
   porcelains.
   #+END_QUOTE

   #+begin_src emacs-lisp
     (use-package magit
       :bind (:map my-keys-minor-mode-map
                   ("C-c gs" . magit-status)
                   ("C-c gc" . magit-commit)
                   ("C-c gp" . magit-push-current)
                   ("C-c gf" . magit-file-dispatch))
       :init
       (setq magit-commit-show-diff nil
             magit-revert-buffers 1))
   #+end_src

   When I use magit, I prefer to have it use the full emacs frame
   instead of splitting the current buffer.
   #+begin_src emacs-lisp
     (use-package fullframe
       :after magit
       :config
       (fullframe magit-status magit-mode-quit-window))
   #+end_src

   Start in insert mode when committing from vcs
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (add-hook 'with-editor-mode-hook 'evil-insert-state))
   #+end_src

** gitsh

   #+BEGIN_QUOTE
   The [[https://github.com/thoughtbot/gitsh][gitsh]] program is an interactive shell for git. From within
   gitsh you can issue any git command, even using your local aliases
   and configuration
   #+END_QUOTE

   When I have to do git related things that are painful to do with
   magit, I just fire a terminal with /gitsh/ for the current project.
   #+begin_src emacs-lisp
     (defun ab-run-gitsh ()
       "Start gitsh in current git project. Uses st as a terminal."
       (interactive)
       (let ((default-directory (locate-dominating-file (expand-file-name default-directory) ".gitignore")))
         (start-process "gitsh" nil "gnome-terminal" "--geometry=120x70" "--class=scratch-term" "--" "gitsh")))
     (define-key my-keys-minor-mode-map (kbd "C-c gg") 'ab-run-gitsh)
   #+end_src

** Visual enhancements

   See in the fringe lines added, changed and removed since last commit.
   #+begin_src emacs-lisp
     (use-package diff-hl
       :after magit
       :config
       (add-hook 'prog-mode-hook 'diff-hl-mode)
       (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
   #+end_src

* IDE
  Emacs is not an IDE but I can be pretty close to one.
  Here are some tools I use that are IDE oriented.

** Find file in project
*** Examples
    #+begin_src emacs-lisp :tangle no
      ;; if the full path of current file is under SUBPROJECT1 or SUBPROJECT2
      ;; OR if I'm reading my personal issue track document,
      (defun my-setup-develop-environment ()
        (interactive)
        (when (ffip-current-full-filename-match-pattern-p "\\(PROJECT_DIR\\|issue-track.org\\)")
          ;; Though PROJECT_DIR is team's project, I care only its sub-directory "subproj1""
          (setq-local ffip-project-root "~/projs/PROJECT_DIR/subproj1")
          ;; well, I'm not interested in concatenated BIG js file or file in dist/
          (setq-local ffip-find-options "-not -size +64k -not -iwholename '*/dist/*'")
          ;; for this project, I'm only interested certain types of files
          (setq-local ffip-patterns '("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
          ;; maybe you want to search files in `bin' directory?
          (setq-local ffip-prune-patterns (delete "*/bin/*" ffip-prune-patterns))
          ;; exclude `dist/' directory
          (add-to-list 'ffip-prune-patterns "*/dist/*"))
        ;; insert more WHEN statements below this line for other projects
        )

      ;; most major modes inherit from prog-mode, so below line is enough
      (add-hook 'prog-mode-hook 'my-setup-develop-environment)
    #+end_src

    All variables may be overridden on a per-directory basis in your
    .dir-locals.el. See (info â(Emacs) Directory Variablesâ) for
    details.

    You can place .dir-locals.el into your project root directory.

    A sample .dir-locals.el,

    #+begin_src emacs-lisp :tangle no
      ((nil . ((ffip-project-root . "~/projs/PROJECT_DIR")
               ;; ignore files bigger than 64k and directory "dist/" when searching
               (ffip-find-options . "-not -size +64k -not -iwholename '*/dist/*'")
               ;; only search files with following extensions
               (ffip-patterns . ("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
               (eval . (progn
                         (require 'find-file-in-project)
                         ;; ignore directory ".tox/" when searching
                         (setq ffip-prune-patterns `("*/.tox/*" ,@ffip-prune-patterns))
                         ;; Do NOT ignore directory "bin/" when searching
                         (setq ffip-prune-patterns `(delete "*/bin/*" ,@ffip-prune-patterns))))
               )))
    #+end_src

*** My config

    To install fd (rust replacement for find), download it
    [[https://github.com/sharkdp/fd/releases][here]] and run ~sudo dpkg -i fd_7.0.0_amd64.deb~. You can then choose
    to use `fd` instead of find.
    #+begin_src emacs-lisp
    (use-package find-file-in-project
      :bind (:map  my-keys-minor-mode-map
                   ("C-c T" . find-file-in-project)
                   ;; ("C-c t" . counsel-fzf)
                   ("C-c t" . find-file-in-project-by-selected)
                   ("C-c s" . abo-find-file-with-similar-name)
                   :map evil-normal-state-map
                   ("gf" . find-file-in-project-at-point))
      :config
      (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.png")) ffip-ignore-filenames))
      (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpg")) ffip-ignore-filenames))
      (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpeg")) ffip-ignore-filenames))
      (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.gif")) ffip-ignore-filenames))
      (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.bmp")) ffip-ignore-filenames))
      (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.ico")) ffip-ignore-filenames))
      (setq ffip-prefer-ido-mode nil)
      (setq ffip-use-rust-fd nil) ;; find works better than fd. fd with ffip ignores my .emacs.d directory for some reason
      (setq ffip-strip-file-name-regex "\\(\\.mock\\|_test\\|\\.test\\|\\.mockup\\|\\.spec\\)")
      (add-to-list 'ffip-prune-patterns "*/.git/*")
      (add-to-list 'ffip-prune-patterns "*/dist/*")
      (add-to-list 'ffip-prune-patterns "*/.emacs.d/elpa/*")
      (add-to-list 'ffip-prune-patterns "*/.nuxt/*")
      (add-to-list 'ffip-prune-patterns "*/spec/coverage/*")
      (add-to-list 'ffip-prune-patterns "*/public/*")
      (add-to-list 'ffip-prune-patterns "*/.shadow-cljs/*")
      (add-to-list 'ffip-prune-patterns "node_modules/*"))
    #+end_src

    #+begin_src emacs-lisp
      (defun abo-find-file-with-similar-name (&optional open-another-window)
        "Use base name of current file as keyword which could be further stripped.
      by `ffip-strip-file-name-regex'.
      If OPEN-ANOTHER-WINDOW is not nil, the file will be opened in new window."
        (interactive "P")
        (when buffer-file-name
          (let* ((keyword (concat (file-name-base buffer-file-name) "") ))
            (if ffip-strip-file-name-regex
                (setq keyword (replace-regexp-in-string ffip-strip-file-name-regex
                                                        ""
                                                        keyword)))
            (ffip-find-files keyword open-another-window))))
    #+end_src
** Switch between projects

   The main command I use with projectile is ~C-c p p~ to switch quickly
   between projects. I keep projectile because I has a lot of functions
   project oriented and I use them from time to time. Also

   ~projectile-commander~ accessible with ~C-c p m~ has a pretty nice UI.
   #+begin_src emacs-lisp
     (use-package projectile
       :demand
       :bind (:map my-keys-minor-mode-map
              ("C-c p" . projectile-command-map))
       :init
       (setq projectile-switch-project-action 'projectile-dired)
       (setq projectile-mode-line-prefix " ")
       :config
       (projectile-mode t))
   #+end_src

** Switch between test and implementation

   This defines a new project type, the interesting part is the test suffix. I
   use it to jump quickly between a test and its implementation.
   Default projectile shortcut for that is ~C-c p t~
   #+begin_src emacs-lisp
     (use-package projectile
       :config
       (projectile-register-project-type 'npm '("package.json")
                                         :compile "npm install"
                                         :test "npm test"
                                         :run "npm start"
                                         :test-suffix ".spec"))
   #+end_src

** Jump

   /dumb-jump/ just do a search through the project to try to guess the
   correct jump location for the current symbol. It is not has good as an
   IDE code analysis but it works surprisingly well.

   I added a small function to make the current line flash just after a jump
   #+begin_src emacs-lisp
     (use-package dumb-jump
       :bind (:map evil-normal-state-map
                   ("gd" . dumb-jump-go)
                   ("gD" . dumb-jump-go-other-window))
       :init
       (setq dumb-jump-selector 'ivy)
       :config
       (add-hook 'dumb-jump-after-jump-hook
                 (defun abo-dumb-jump-pulse-line ()
                   (pulse-momentary-highlight-one-line (point)))))
   #+end_src

** Tags

   Tags are generated through a [[file:~/dotfiles/git/.git_template/hooks/post-commit::.git/hooks/create_ctags%20>/dev/null%202>&1%20&][git hook]] with [[https://ctags.io/][Universal ctags]].

   To make sure my hooks are used I delete the hooks directory
   ~./git/config~ and run ~git init .~ again from the concerned project
   directory.

   My [[file:~/dotfiles/git/.git_template][templates]] are used thanks to the [[~GIT_TEMPLATE_DIR][~GIT_TEMPLATE_DIR~]] environment variable.
   #+begin_src shell :results output
   env | grep GIT_TEMPLATE_DIR
   #+end_src

   #+RESULTS:
   : GIT_TEMPLATE_DIR=/home/auray/.git_template

   I install Universal ctags with
   #+begin_src shell :results output
   brew install --HEAD universal-ctags/universal-ctags/universal-ctags
   #+end_src

   To verify you have the proper version of universal ctags run
   #+begin_src shell :results output
   ctags --version | grep -q "Universal Ctags" >/dev/null && echo "Universal ctags is installed" || echo "Missing Universal ctags"
   #+end_src

   #+RESULTS:
   : Universal ctags is installed

   These are my two go commands to navigate between code references.
   #+begin_src emacs-lisp
   (use-package evil
     :bind (:map evil-normal-state-map
                   ("g." . xref-find-definitions)
                   ("gr" . xref-find-references)))
   #+end_src

* completion
** Hippie expand
   Bound to ~s-/~, it provides a simple on demand completion mechanism.
   You can customize its behaviour by choosing different expand functions.

   The description of all the hippie expand functions is inside
   [[https://github.com/emacs-mirror/emacs/blob/master/lisp/hippie-exp.el#L63][~hippie-exp.el~]] (location can vary on your system)
   #+begin_src emacs-lisp
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line))
    (require 'mode-local)
    (setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol))
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-all-abbrevs try-expand-line))
    (require 'mode-local)
    (setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-all-abbrevs try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol))
    (define-key evil-insert-state-map (kbd "s-/") 'hippie-expand)
   #+end_src

** AutoCompletion

   company shows a popup where you can select completions with a number
   or with ~enter~. You can also invoke the popup manually with ~C-x
   C-o~
   #+begin_src emacs-lisp
      (use-package company
        :diminish company-mode
        :config
        (add-hook 'after-init-hook 'global-company-mode)
        (setq company-dabbrev-downcase nil)
        (setq company-show-numbers t)
        (setq company-backends '((company-files company-capf company-dabbrev)))

        (define-key evil-insert-state-map (kbd "C-x C-o") 'company-complete)
        (let ((map company-active-map))
          (mapc
           (lambda (x)
             (define-key map (format "%d" x) 'ora-company-number))
           (number-sequence 0 9))
          (define-key map " " (lambda ()
                                (interactive)
                                (company-abort)
                                (self-insert-command 1)))
          (define-key map (kbd "<return>") nil))

        (defun ora-company-number ()
          "Forward to `company-complete-number'.

        Unless the number is potentially part of the candidate.
        In that case, insert the number."
          (interactive)
          (let* ((k (this-command-keys))
                 (re (concat "^" company-prefix k)))
            (if (cl-find-if (lambda (s) (string-match re s))
                            company-candidates)
                (self-insert-command 1)
              (company-complete-number (string-to-number k))))))
   #+end_src

** Snippets

   #+begin_src emacs-lisp
     (use-package yasnippet
       :demand
       :commands yas-expand-snippet
       :bind (:map my-keys-minor-mode-map
                   ("C-c yd" . yas-describe-tables))
       :diminish yas-minor-mode
       :init
       (setq yas-snippet-dirs
             '("~/.emacs.d/snippets"))
       :config
       (yas-global-mode 1)
       (add-hook 'term-mode-hook (lambda()
                                   (yas-minor-mode -1))))
   #+end_src

   This allow me to automatically expand [[https://github.com/aurelienbottazini/dotfiles/blob/master/emacs/.emacs.d/templates/][templates]] into new files using
   the yasnippet format. The filenames for the template are regexes.
   #+begin_src emacs-lisp
     (use-package yatemplate
       :config
       (add-hook 'find-file-hook 'auto-insert)
       (yatemplate-fill-alist))
   #+end_src

* files and directories

** Dired
   #+begin_src emacs-lisp
     (setq ls-lisp-use-insert-directory-program t) ;same ls-lisp for Dired regardless of the platform
     (setq dired-listing-switches "-alh")
     ;; on mac there is some weird prefixing going on for GNU Tools like ls.
     ;; I favor GNU ls over MacOSX default ls
     (when (string-equal system-type "darwin")
       (setq insert-directory-program "gls"))

     (require 'dired )
     (defun my-dired-mode-setup ()
       "to be run as hook for `dired-mode'."
       (dired-hide-details-mode 1))
     (add-hook 'dired-mode-hook 'my-dired-mode-setup)

     (put 'dired-find-alternate-file 'disabled nil)
     (setq dired-dwim-target t)
     (add-hook 'dired-load-hook
               (lambda ()
                 (load "dired-x")
                 ;; Set dired-x global variables here.  For example:
                 ;; (setq dired-guess-shell-gnutar "gtar")
                 ;; (setq dired-x-hands-off-my-keys nil)
                 (setq dired-recursive-copies (quote always)) ; âalwaysâ means no asking
                 (setq dired-recursive-deletes (quote top)) ; âtopâ means ask once
                 ))

     (eval-after-load "dired"
       '(progn
          (define-key dired-mode-map "-" 'dired-up-directory)
          (define-key dired-mode-map (kbd "C-u k") 'dired-kill-subdir)
          (define-key dired-mode-map (kbd "/") 'evil-search-forward)
          (define-key dired-mode-map (kbd "j") 'dired-next-line)
          (define-key dired-mode-map (kbd "k") 'dired-previous-line)
          (define-key dired-mode-map (kbd "[b") 'previous-buffer)
          (define-key dired-mode-map (kbd "]b") 'next-buffer)
          (evil-define-key 'normal dired-mode-map
            "gg" 'evil-goto-first-line
            "^" '(lambda () (interactive) (find-alternate-file "..")))))

     (define-key package-menu-mode-map (kbd "/") 'evil-search-forward)

     (use-package dired-rsync
     :config
     (bind-key "p" 'dired-rsync dired-mode-map))
   #+end_src

** Counsel
   I redefine the standard ~C-x C-f~ to use counsel. It allows me to do
   pretty cool stuff with it [[https://oremacs.com/2017/11/18/dired-occur/][thanks to ivy-occur and dired]].

   #+BEGIN_QUOTE
   To delete all *.elc files in the current folder do:

   ~C-x C-f elc$ C-c C-o tDy.~

   To copy all Org files in a Git project to some directory do:

   ~M-x counsel-git org$ C-c C-o tC.~

   To get a list of videos to watch do:

   ~M-x counsel-fzf mp4$ C-c C-o.~
   #+END_QUOTE

   #+begin_src emacs-lisp
   (use-package counsel
     :bind (("C-x C-f" . counsel-find-file)))
   #+end_src

* Testing things
  #+begin_src emacs-lisp
      (when (fboundp 'winner-mode)
      (winner-mode 1))
  #+end_src

  #+begin_src emacs-lisp :results raw
(setq org-babel-js-function-wrapper "require('util').log(require('util').inspect(function(){%s}()));")
(use-package go-mode)
(use-package web-mode
  :mode "\\.html\\'"
  :mode "\\.gohtml\\'")
  #+end_src

  #+begin_src emacs-lisp
(use-package writeroom-mode
  :bind (:map my-keys-minor-mode-map
  ("C-c z" . writeroom-mode)))
  #+end_src

  #+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation nil
      org-html-indent nil
      org-edit-src-content-indentation 0)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
(defun abo-jump-to-note-file ()
  "Jump to org note file for current buffer"
  (interactive)
  (find-file **local-note-file**))

(define-key my-keys-minor-mode-map "\C-cn" 'abo-jump-to-note-file)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
(defun abo-change-line-endings-to-unix ()
  (let ((coding-str (symbol-name buffer-file-coding-system)))
    (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      (set-buffer-file-coding-system 'unix))))

(add-hook 'find-file-hooks 'abo-change-line-endings-to-unix)
  #+END_SRC

  #+begin_src emacs-lisp
(use-package markdown-mode)
  #+end_src
